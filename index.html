<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼ 3D</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #bdefff; /* ãƒ‘ã‚¹ãƒ†ãƒ«ç©ºè‰² */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none; /* iPadã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æŠ‘æ­¢ */
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    /* UI å…±é€š */
    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      color: #333;
    }
    #top-ui {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      text-shadow: 0 1px 2px rgba(255,255,255,0.8);
    }
    #left-ui {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #hearts {
      font-size: 20px;
    }
    #hp-bar {
      width: 140px;
      height: 12px;
      border-radius: 8px;
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.1);
      overflow: hidden;
    }
    #hp-bar-inner {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #ff9aa2, #ffdac1);
      transition: width 0.15s ease-out;
    }
    #score {
      font-size: 18px;
      font-weight: bold;
    }

    /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ */
    .center-panel {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    .panel-box {
      background: rgba(255,255,255,0.9);
      border-radius: 16px;
      padding: 20px 24px;
      max-width: 360px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.15);
      text-align: center;
    }
    .panel-box h1 {
      margin: 0 0 8px;
      font-size: 26px;
    }
    .panel-box p {
      margin: 4px 0;
      font-size: 14px;
      line-height: 1.5;
    }
    .btn-main {
      margin-top: 12px;
      padding: 10px 20px;
      border-radius: 999px;
      border: none;
      font-size: 16px;
      font-weight: bold;
      background: linear-gradient(135deg, #ffcfdf, #fefdca);
      color: #333;
      box-shadow: 0 3px 0 rgba(255, 170, 180, 1);
    }
    .btn-main:active {
      transform: translateY(1px);
      box-shadow: 0 1px 0 rgba(255, 170, 180, 1);
    }

    #title-screen { }
    #gameover-screen { display: none; }

    #damage-flash {
      position: absolute;
      inset: 0;
      background: rgba(255, 0, 0, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease-out;
    }

    #message-text {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 999px;
      background: rgba(255,255,255,0.85);
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div id="ui-layer">
    <div id="top-ui">
      <div id="left-ui">
        <div id="hearts">â¤ï¸â¤ï¸â¤ï¸</div>
        <div id="hp-bar"><div id="hp-bar-inner"></div></div>
      </div>
      <div id="score">SCORE: 0</div>
    </div>

    <div id="title-screen" class="center-panel">
      <div class="panel-box">
        <h1>ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼ ğŸ¤</h1>
        <p>ä¸Šã‚¹ãƒ¯ã‚¤ãƒ—ï¼šå¥¥ã®ãƒ¬ãƒ¼ãƒ³ã¸</p>
        <p>ä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—ï¼šæ‰‹å‰ã®ãƒ¬ãƒ¼ãƒ³ã¸</p>
        <p>ã‚¿ãƒƒãƒ—ï¼šã‚¸ãƒ£ãƒ³ãƒ—</p>
        <p style="margin-top:8px; font-size:13px; color:#555;">
          ãƒˆã‚²ãƒ»çˆ†å¼¾ãƒ»ç©´ã‚’ã‚ˆã‘ãªãŒã‚‰<br />
          å›å¾©ãƒœãƒ¼ãƒ«ã¨æ˜Ÿã‚’é›†ã‚ã‚ˆã†ï¼
        </p>
        <button id="start-button" class="btn-main">START</button>
      </div>
    </div>

    <div id="gameover-screen" class="center-panel">
      <div class="panel-box">
        <h1>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1>
        <p id="final-score">SCORE: 0</p>
        <button id="restart-button" class="btn-main">ã‚‚ã†ä¸€åº¦</button>
      </div>
    </div>

    <div id="damage-flash"></div>
    <div id="message-text"></div>
  </div>

  <!-- Three.js CDN èª­ã¿è¾¼ã¿ -->
  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>

  <script>
    // ================================
    //  åŸºæœ¬è¨­å®š
    // ================================
    let scene, camera, renderer;
    let clock;
    let container = document.getElementById('game-container');

    // ãƒ¬ãƒ¼ãƒ³æ•°ã¨Zä½ç½®ï¼ˆ0: æ‰‹å‰, 3: å¥¥ï¼‰
    const LANE_COUNT = 4;
    const LANE_Z_STEP = 1.6;
    const LANE_Z_START = 2.4; // lane=0 -> z=2.4, lane=3 -> z=-2.4

    function laneToZ(lane) {
      return LANE_Z_START - lane * LANE_Z_STEP;
    }

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let gameState = 'title'; // 'title' | 'playing' | 'gameover'

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–¢é€£
    let player;
    let playerLane = 1; // åˆæœŸã¯æ‰‹å‰ã‹ã‚‰2ç•ªç›®(1)
    let targetLane = 1;
    let laneLerpSpeed = 10.0;
    let jumpVelocity = 7.5;
    let longJumpVelocity = 10.0;
    let gravity = 20.0;
    let verticalVelocity = 0;
    let isJumping = false;
    const GROUND_Y = 0.9;

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    let lives = 3;
    let maxHP = 100;
    let hp = 100;
    let score = 0;

    // ç„¡æ•µçŠ¶æ…‹
    let isInvincible = false;
    let invincibleTimer = 0;
    let invincibleDuration = 5.0; // ç§’
    let invincibleStars = [];

    // ã‚¹ãƒ”ãƒ¼ãƒ‰
    let baseSpeed = 8;
    let speed = baseSpeed;
    let speedIncreaseRate = 0.03; // ç§’ã”ã¨ã«å°‘ã—åŠ é€Ÿ
    let elapsedTime = 0;

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—
    let hazards = [];    // ãƒˆã‚²ãƒ»çˆ†å¼¾
    let items = [];      // å›å¾©çƒãƒ»æ˜Ÿ
    let traps = [];      // çŸ¢å°åºŠãƒ»ãƒ­ã‚¤ã‚¿ãƒ¼æ¿ãƒ»ç©´
    let backgrounds = [];// å±±ãƒ»é›²ãªã©

    // ã‚¹ãƒãƒ¼ãƒ³é–¢é€£
    let hazardTimer = 0;
    let itemTimer = 0;
    let trapTimer = 0;
    const SPAWN_X = 20;
    const DESPAWN_X = -15;

    // UI è¦ç´ 
    const heartsEl = document.getElementById('hearts');
    const hpInnerEl = document.getElementById('hp-bar-inner');
    const scoreEl = document.getElementById('score');
    const damageFlashEl = document.getElementById('damage-flash');
    const messageTextEl = document.getElementById('message-text');
    const titleScreenEl = document.getElementById('title-screen');
    const gameoverScreenEl = document.getElementById('gameover-screen');
    const finalScoreEl = document.getElementById('final-score');

    // ã‚¿ãƒƒãƒå…¥åŠ›
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;

    // ================================
    //  åˆæœŸåŒ–
    // ================================
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xbdefff);

      const width = window.innerWidth;
      const height = window.innerHeight;

      // ã‚«ãƒ¡ãƒ©è¨­å®šï¼ˆã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼ãƒ“ãƒ¥ãƒ¼ï¼‰
      camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 100);
      camera.position.set(-6, 8, 6);
      camera.lookAt(new THREE.Vector3(0, 1.5, 0));

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      clock = new THREE.Clock();

      // ç’°å¢ƒå…‰ã¨æ–¹å‘å…‰
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0xb0e0e6, 0.7);
      hemiLight.position.set(0, 10, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
      dirLight.position.set(5, 10, 5);
      scene.add(dirLight);

      // åœ°é¢ã¨ãƒ¬ãƒ¼ãƒ³
      createGround();

      // èƒŒæ™¯ã®å±±ã¨é›²
      createBackgroundObjects();

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”Ÿæˆ
      createPlayer();

      // UI åˆæœŸè¡¨ç¤º
      updateUI();

      // ã‚¤ãƒ™ãƒ³ãƒˆ
      window.addEventListener('resize', onWindowResize);
      setupTouchControls();

      // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
      document.getElementById('start-button').addEventListener('click', () => {
        startGame();
      });
      document.getElementById('restart-button').addEventListener('click', () => {
        startGame();
      });

      animate();
    }

    // ================================
    //  åœ°é¢ã¨èƒŒæ™¯
    // ================================
    // ãƒ¬ãƒ¼ãƒ³ã”ã¨ã®åºŠã‚’ã‚¿ã‚¤ãƒ«çŠ¶ã«ä¸¦ã¹ã‚‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªãƒ«ãƒ¼ãƒ—ï¼‰
    function createGround() {
      const tileLength = 2.5;
      const tileWidth = 1.2;
      const numTiles = 20;

      const baseColors = [0xfdfd96, 0xfff1b5, 0xfff6cf, 0xf9f9b5];

      for (let lane = 0; lane < LANE_COUNT; lane++) {
        const z = laneToZ(lane);
        for (let i = 0; i < numTiles; i++) {
          const geo = new THREE.BoxGeometry(tileLength, 0.2, tileWidth);
          const mat = new THREE.MeshPhongMaterial({ color: baseColors[lane % baseColors.length] });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(-i * tileLength, 0, z);
          mesh.userData.isGroundTile = true;
          mesh.userData.lane = lane;
          mesh.userData.index = i;
          scene.add(mesh);
        }
      }

      // TODO: åœ°é¢ã‚¿ã‚¤ãƒ«ã«å¯¾ã—ã¦ç´°ã‹ã„ç©´è¡¨ç¾ã‚’åŒæœŸã•ã›ã‚‹å®Ÿè£…ã‚’è¿½åŠ ã—ã¦ã‚‚ã‚ˆã„
    }

    // ãƒ‘ã‚¹ãƒ†ãƒ«èª¿ã®å±±ãƒ»é›²ã‚’å¥¥ã«é…ç½®
    function createBackgroundObjects() {
      const bgGroup = new THREE.Group();

      // å±±
      for (let i = 0; i < 6; i++) {
        const geo = new THREE.ConeGeometry(2 + Math.random() * 1.5, 2.5 + Math.random() * 2, 6);
        const mat = new THREE.MeshPhongMaterial({ color: 0xc5e1a5, flatShading: true });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(5 + i * 4, 0, -5 - Math.random() * 4);
        mesh.rotation.y = Math.random() * Math.PI;
        bgGroup.add(mesh);
      }

      // é›²
      for (let i = 0; i < 5; i++) {
        const cloud = new THREE.Group();
        const baseColor = new THREE.Color(0xffffff);
        for (let j = 0; j < 3; j++) {
          const geo = new THREE.SphereGeometry(1 + Math.random() * 0.4, 8, 8);
          const mat = new THREE.MeshPhongMaterial({ color: baseColor, flatShading: true });
          const s = new THREE.Mesh(geo, mat);
          s.position.set(j * 1.4, 3 + Math.random(), 0);
          cloud.add(s);
        }
        cloud.position.set(5 + i * 5, 0, -3 - Math.random() * 4);
        bgGroup.add(cloud);
      }

      scene.add(bgGroup);
      backgrounds.push(bgGroup);
    }

    // ================================
    //  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”Ÿæˆ
    // ================================
    function createPlayer() {
      const group = new THREE.Group();

      // ä½“
      const bodyGeo = new THREE.SphereGeometry(0.6, 16, 16);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0xffeb3b, flatShading: true });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 0.6, 0);
      group.add(body);

      // ãã¡ã°ã—
      const beakGeo = new THREE.ConeGeometry(0.2, 0.4, 8);
      const beakMat = new THREE.MeshPhongMaterial({ color: 0xffa726, flatShading: true });
      const beak = new THREE.Mesh(beakGeo, beakMat);
      beak.rotation.z = Math.PI / 2;
      beak.position.set(0.6, 0.55, 0);
      group.add(beak);

      // è¶³
      const legGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.4, 8);
      const legMat = new THREE.MeshPhongMaterial({ color: 0xffa726, flatShading: true });
      const leg1 = new THREE.Mesh(legGeo, legMat);
      leg1.position.set(-0.15, 0.2, 0.15);
      const leg2 = leg1.clone();
      leg2.position.z = -0.15;
      group.add(leg1);
      group.add(leg2);

      group.position.set(0, GROUND_Y, laneToZ(playerLane));

      scene.add(group);
      player = group;
    }

    // ================================
    //  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    // ================================
    // ãƒˆã‚²ä»˜ããƒœãƒ¼ãƒ«ï¼ˆåœ°ä¸Šãƒ»ç©ºä¸­ï¼‰
    function createSpike(isAir) {
      const group = new THREE.Group();

      const coreGeo = new THREE.SphereGeometry(0.4, 8, 8);
      const color = isAir ? 0xffcc80 : 0xff7043; // ç©ºä¸­: ã‚ªãƒ¬ãƒ³ã‚¸, åœ°ä¸Š: èµ¤ã‚ªãƒ¬ãƒ³ã‚¸
      const coreMat = new THREE.MeshPhongMaterial({ color, flatShading: true });
      const core = new THREE.Mesh(coreGeo, coreMat);
      group.add(core);

      // ç°¡æ˜“ãƒˆã‚²ã‚’æ•°æœ¬
      const spikeGeo = new THREE.ConeGeometry(0.15, 0.4, 5);
      const spikeMat = new THREE.MeshPhongMaterial({ color: 0xffccbc, flatShading: true });
      const spikeOffsets = [
        new THREE.Vector3(0.4, 0, 0),
        new THREE.Vector3(-0.4, 0, 0),
        new THREE.Vector3(0, 0.4, 0),
        new THREE.Vector3(0, -0.2, 0.4),
        new THREE.Vector3(0, -0.2, -0.4)
      ];
      spikeOffsets.forEach(v => {
        const s = new THREE.Mesh(spikeGeo, spikeMat);
        s.position.copy(v);
        s.lookAt(0, 0, 0);
        group.add(s);
      });

      return group;
    }

    // çˆ†å¼¾
    function createBomb() {
      const group = new THREE.Group();
      const bodyGeo = new THREE.SphereGeometry(0.5, 12, 12);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0x333333, flatShading: true });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);

      const fuseGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.3, 8);
      const fuseMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, flatShading: true });
      const fuse = new THREE.Mesh(fuseGeo, fuseMat);
      fuse.position.set(0, 0.65, 0);
      group.add(fuse);

      return group;
    }

    // å›å¾©çƒ
    function createHealOrb() {
      const geo = new THREE.SphereGeometry(0.4, 12, 12);
      const mat = new THREE.MeshPhongMaterial({ color: 0xb39ddb, emissive: 0x7e57c2, flatShading: true });
      return new THREE.Mesh(geo, mat);
    }

    // æ˜Ÿã‚¢ã‚¤ãƒ†ãƒ 
    function createStarItem() {
      const group = new THREE.Group();
      const geo = new THREE.OctahedronGeometry(0.4, 0);
      const mat = new THREE.MeshPhongMaterial({ color: 0xffeb3b, emissive: 0xfff176, flatShading: true });
      const star = new THREE.Mesh(geo, mat);
      group.add(star);
      return group;
    }

    // çŸ¢å°åºŠ
    function createArrowTile(dir) {
      const group = new THREE.Group();
      const tileGeo = new THREE.BoxGeometry(1.5, 0.22, 1.0);
      const tileMat = new THREE.MeshPhongMaterial({ color: 0x81d4fa, flatShading: true });
      const tile = new THREE.Mesh(tileGeo, tileMat);
      group.add(tile);

      const arrowGeo = new THREE.ConeGeometry(0.25, 0.6, 6);
      const arrowMat = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });
      const arrow = new THREE.Mesh(arrowGeo, arrowMat);
      arrow.rotation.z = dir > 0 ? Math.PI : 0; // ä¸ŠçŸ¢å°(å¥¥) or ä¸‹çŸ¢å°(æ‰‹å‰)
      arrow.position.set(0, 0.4, 0);
      group.add(arrow);
      return group;
    }

    // ãƒ­ã‚¤ã‚¿ãƒ¼æ¿
    function createSpringTile() {
      const geo = new THREE.BoxGeometry(1.5, 0.22, 1.0);
      const mat = new THREE.MeshPhongMaterial({ color: 0xfff59d, emissive: 0xfff59d, flatShading: true });
      return new THREE.Mesh(geo, mat);
    }

    // åœ°é¢ã®ç©´ï¼ˆè¦‹ãŸç›®ç”¨ã®æš—ã„ã‚¿ã‚¤ãƒ«ï¼‰
    function createHoleTile() {
      const geo = new THREE.BoxGeometry(1.5, 0.05, 1.0);
      const mat = new THREE.MeshPhongMaterial({ color: 0x424242, flatShading: true });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = 0.01;
      return mesh;
    }

    // ç„¡æ•µç”¨ã®æ˜Ÿãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
    function createInvincibleStars() {
      invincibleStars.forEach(s => scene.remove(s));
      invincibleStars.length = 0;
      for (let i = 0; i < 4; i++) {
        const geo = new THREE.OctahedronGeometry(0.2, 0);
        const mat = new THREE.MeshPhongMaterial({ color: 0xfff176, emissive: 0xfff176, flatShading: true });
        const star = new THREE.Mesh(geo, mat);
        scene.add(star);
        invincibleStars.push(star);
      }
    }

    // ================================
    //  ã‚²ãƒ¼ãƒ é–‹å§‹ãƒ»ãƒªã‚»ãƒƒãƒˆ
    // ================================
    function resetWorldObjects() {
      hazards.forEach(o => scene.remove(o.mesh));
      items.forEach(o => scene.remove(o.mesh));
      traps.forEach(o => scene.remove(o.mesh));
      hazards.length = 0;
      items.length = 0;
      traps.length = 0;
      invincibleStars.forEach(s => scene.remove(s));
      invincibleStars.length = 0;
    }

    function resetPlayerState() {
      playerLane = 1;
      targetLane = 1;
      verticalVelocity = 0;
      isJumping = false;
      player.position.set(0, GROUND_Y, laneToZ(playerLane));
      lives = 3;
      hp = 100;
      score = 0;
      isInvincible = false;
      invincibleTimer = 0;
      elapsedTime = 0;
      speed = baseSpeed;

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
      player.children.forEach(ch => {
        if (ch.material) {
          ch.material.color.set(0xffeb3b);
          ch.material.emissive && ch.material.emissive.set(0x000000);
        }
      });
    }

    function startGame() {
      gameState = 'playing';
      titleScreenEl.style.display = 'none';
      gameoverScreenEl.style.display = 'none';
      resetWorldObjects();
      resetPlayerState();
      clock.getDelta(); // å‰ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“ã‚’ã‚¯ãƒªã‚¢
      showMessage('ãŒã‚“ã°ã£ã¦èµ°ã‚ã†ï¼');
    }

    function gameOver() {
      gameState = 'gameover';
      finalScoreEl.textContent = 'SCORE: ' + Math.floor(score);
      gameoverScreenEl.style.display = 'flex';
      showMessage('');
    }

    // ================================
    //  UI æ›´æ–°
    // ================================
    function updateUI() {
      heartsEl.textContent = 'â¤ï¸'.repeat(lives) + 'ğŸ–¤'.repeat(Math.max(0, 3 - lives));
      const hpRatio = Math.max(0, Math.min(1, hp / maxHP));
      hpInnerEl.style.width = (hpRatio * 100) + '%';
      scoreEl.textContent = 'SCORE: ' + Math.floor(score);
    }

    function showDamageEffect() {
      damageFlashEl.style.opacity = '1';
      setTimeout(() => {
        damageFlashEl.style.opacity = '0';
      }, 120);
    }

    let messageTimer = 0;
    function showMessage(text, duration = 1.3) {
      if (!text) {
        messageTextEl.style.opacity = '0';
        messageTimer = 0;
        return;
      }
      messageTextEl.textContent = text;
      messageTextEl.style.opacity = '1';
      messageTimer = duration;
    }

    // ================================
    //  ã‚¿ãƒƒãƒå…¥åŠ›
    // ================================
    function setupTouchControls() {
      window.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartTime = performance.now();
      }, { passive: false });

      window.addEventListener('touchmove', (e) => {
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
        e.preventDefault();
      }, { passive: false });

      window.addEventListener('touchend', (e) => {
        if (gameState !== 'playing') return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const dt = performance.now() - touchStartTime;
        const dist = Math.sqrt(dx * dx + dy * dy);

        const SWIPE_THRESHOLD = 40;

        if (dist < 12 || dt < 180) {
          // ã‚¿ãƒƒãƒ—ã¨ã¿ãªã™
          handleTap();
        } else {
          if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > SWIPE_THRESHOLD) {
            if (dy < 0) handleSwipeUp();
            else handleSwipeDown();
          } else {
            // æ¨ªã‚¹ãƒ¯ã‚¤ãƒ—ã¯ç‰¹ã«ä½•ã‚‚ã—ãªã„
          }
        }
      }, { passive: false });
    }

    function handleTap() {
      // ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆç©ºä¸­ã§ã¯äºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—ãªã—ï¼‰
      if (!isJumping) {
        verticalVelocity = jumpVelocity;
        isJumping = true;
      }
    }

    function handleSwipeUp() {
      if (targetLane < LANE_COUNT - 1) {
        targetLane++;
      }
    }

    function handleSwipeDown() {
      if (targetLane > 0) {
        targetLane--;
      }
    }

    // ================================
    //  ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†
    // ================================
    function spawnHazard() {
      const r = Math.random();
      const lane = Math.floor(Math.random() * LANE_COUNT);
      const z = laneToZ(lane);
      let mesh, type;
      let baseY = 0.6;
      if (r < 0.45) {
        // åœ°ä¸Šãƒˆã‚²
        mesh = createSpike(false);
        mesh.position.set(SPAWN_X, 0.5, z);
        type = 'spikeGround';
      } else if (r < 0.75) {
        // ç©ºä¸­ãƒˆã‚²
        mesh = createSpike(true);
        mesh.position.set(SPAWN_X, 2.0, z);
        type = 'spikeAir';
        baseY = 2.0;
      } else {
        // çˆ†å¼¾
        mesh = createBomb();
        mesh.position.set(SPAWN_X, 0.5, z);
        type = 'bomb';
      }
      scene.add(mesh);
      hazards.push({ mesh, type, lane, baseY, time: 0 });
    }

    function spawnItem() {
      const lane = Math.floor(Math.random() * LANE_COUNT);
      const z = laneToZ(lane);

      // HP ãŒå°‘ãªã„ã¨ãã¯å›å¾©çƒå„ªå…ˆ
      const needHeal = hp <= 30;
      const r = Math.random();
      let mesh, type;
      if (needHeal) {
        if (r < 0.7) {
          mesh = createHealOrb();
          type = 'heal';
        } else {
          mesh = createStarItem();
          type = 'star';
        }
      } else {
        if (r < 0.4) {
          mesh = createHealOrb();
          type = 'heal';
        } else {
          mesh = createStarItem();
          type = 'star';
        }
      }
      mesh.position.set(SPAWN_X, 1.8, z);
      scene.add(mesh);
      items.push({ mesh, type, lane, time: 0 });
    }

    function spawnTrap() {
      const lane = Math.floor(Math.random() * LANE_COUNT);
      const z = laneToZ(lane);
      const r = Math.random();

      let mesh, type;
      if (r < 0.33) {
        // çŸ¢å°åºŠ
        const dir = Math.random() < 0.5 ? 1 : -1; // 1: å¥¥ã¸, -1: æ‰‹å‰ã¸
        mesh = createArrowTile(dir);
        mesh.userData.arrowDir = dir;
        mesh.position.set(SPAWN_X, 0.1, z);
        type = 'arrow';
      } else if (r < 0.66) {
        // ãƒ­ã‚¤ã‚¿ãƒ¼æ¿
        mesh = createSpringTile();
        mesh.position.set(SPAWN_X, 0.1, z);
        type = 'spring';
      } else {
        // ç©´
        mesh = createHoleTile();
        mesh.position.set(SPAWN_X, 0.02, z);
        type = 'hole';
      }
      scene.add(mesh);
      traps.push({ mesh, type, lane });
    }

    // ================================
    //  å½“ãŸã‚Šåˆ¤å®šã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å‡¦ç†
    // ================================
    function applyDamage(amount) {
      if (isInvincible || gameState !== 'playing') return;
      hp -= amount;
      if (hp <= 0) {
        hp = 0;
        lives -= 1;
        if (lives <= 0) {
          lives = 0;
          updateUI();
          showDamageEffect();
          gameOver();
          return;
        } else {
          hp = maxHP;
          showMessage('ãƒ©ã‚¤ãƒ•ãŒ 1 æ¸›ã£ãŸã‚ˆâ€¦');
        }
      }
      showDamageEffect();
      updateUI();
    }

    function healHP(amount) {
      hp = Math.min(maxHP, hp + amount);
      updateUI();
    }

    function triggerInstantDeath(reason) {
      if (isInvincible || gameState !== 'playing') return;
      lives = 0;
      hp = 0;
      updateUI();
      showDamageEffect();
      showMessage(reason || 'ã‚„ã‚‰ã‚Œã¦ã—ã¾ã£ãŸâ€¦');
      gameOver();
    }

    function startInvincible() {
      isInvincible = true;
      invincibleTimer = invincibleDuration;
      createInvincibleStars();
      showMessage('ç„¡æ•µãƒ¢ãƒ¼ãƒ‰ï¼');
      speed = baseSpeed * 1.3;
    }

    function updateInvincible(dt) {
      if (!isInvincible) return;
      invincibleTimer -= dt;
      if (invincibleTimer <= 0) {
        isInvincible = false;
        invincibleTimer = 0;
        invincibleStars.forEach(s => scene.remove(s));
        invincibleStars.length = 0;
        speed = baseSpeed;
        showMessage('ç„¡æ•µçµ‚äº†â€¦');
      } else {
        // æ˜Ÿãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨ã‚Šã«å›ã™
        const radius = 1.1;
        const now = performance.now() * 0.002;
        for (let i = 0; i < invincibleStars.length; i++) {
          const angle = now + (Math.PI * 2 * i) / invincibleStars.length;
          const sx = player.position.x + Math.cos(angle) * radius;
          const sz = player.position.z + Math.sin(angle) * radius;
          const sy = player.position.y + 0.2 + 0.1 * Math.sin(now * 2 + i);
          invincibleStars[i].position.set(sx, sy, sz);
        }
      }
    }

    // ================================
    //  æ›´æ–°ãƒ«ãƒ¼ãƒ—
    // ================================
    function update(dt) {
      elapsedTime += dt;
      // ã‚¹ãƒ”ãƒ¼ãƒ‰å¾ã€…ã«ä¸Šæ˜‡ï¼ˆä¸Šé™æ§ãˆã‚ï¼‰
      baseSpeed = 8 + Math.min(6, elapsedTime * speedIncreaseRate);
      if (!isInvincible) {
        speed = baseSpeed;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¬ãƒ¼ãƒ³è£œé–“
      const targetZ = laneToZ(targetLane);
      const currentZ = player.position.z;
      const newZ = THREE.MathUtils.lerp(currentZ, targetZ, Math.min(1, laneLerpSpeed * dt));
      player.position.z = newZ;
      playerLane = targetLane;

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¸ãƒ£ãƒ³ãƒ—ãƒ»é‡åŠ›
      if (isJumping) {
        verticalVelocity -= gravity * dt;
        player.position.y += verticalVelocity * dt;
        if (player.position.y <= GROUND_Y) {
          player.position.y = GROUND_Y;
          verticalVelocity = 0;
          isJumping = false;
        }
      } else {
        // åœ°é¢ã«ã„ã‚‹ã¨ãã¯å°‘ã—ä¸Šä¸‹ã«æºã‚‰ã™
        player.position.y = GROUND_Y + Math.sin(performance.now() * 0.005) * 0.06;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è»½ã„å·¦å³ã‚†ã‚Œ
      player.rotation.y = Math.sin(performance.now() * 0.004) * 0.1;

      // èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚†ã£ãã‚Šæµã™
      backgrounds.forEach(bg => {
        bg.position.x -= speed * dt * 0.2;
        if (bg.position.x < -20) {
          bg.position.x += 40;
        }
      });

      // ã‚¹ãƒãƒ¼ãƒ³ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
      hazardTimer -= dt;
      itemTimer -= dt;
      trapTimer -= dt;

      if (hazardTimer <= 0) {
        spawnHazard();
        hazardTimer = 1.2 / (1 + elapsedTime * 0.03);
      }
      if (itemTimer <= 0) {
        spawnItem();
        itemTimer = 3.0 / (1 + elapsedTime * 0.01);
      }
      if (trapTimer <= 0) {
        spawnTrap();
        trapTimer = 2.5;
      }

      // éšœå®³ç‰©ã®ç§»å‹•ãƒ»å½“ãŸã‚Šåˆ¤å®š
      const px = player.position.x;
      const py = player.position.y;
      const pz = player.position.z;

      for (let i = hazards.length - 1; i >= 0; i--) {
        const obj = hazards[i];
        obj.mesh.position.x -= speed * dt;
        obj.time += dt;
        if (obj.type === 'spikeAir') {
          obj.mesh.position.y = obj.baseY + Math.sin(obj.time * 3) * 0.5;
        }
        // ãƒ‡ã‚¹ãƒãƒ¼ãƒ³
        if (obj.mesh.position.x < DESPAWN_X) {
          scene.remove(obj.mesh);
          hazards.splice(i, 1);
          continue;
        }
        // å½“ãŸã‚Šåˆ¤å®š
        const dx = obj.mesh.position.x - px;
        const dz = obj.mesh.position.z - pz;
        const dy = obj.mesh.position.y - py;
        const distSq = dx * dx + dz * dz + dy * dy;
        const hitDist = obj.type === 'bomb' ? 0.9 : 0.8;
        if (distSq < hitDist * hitDist) {
          if (obj.type === 'bomb') {
            triggerInstantDeath('çˆ†å¼¾ã«å½“ãŸã£ãŸï¼');
          } else {
            applyDamage(28);
          }
          scene.remove(obj.mesh);
          hazards.splice(i, 1);
        }
      }

      // ã‚¢ã‚¤ãƒ†ãƒ 
      for (let i = items.length - 1; i >= 0; i--) {
        const obj = items[i];
        obj.mesh.position.x -= speed * dt;
        obj.time += dt;
        obj.mesh.position.y += Math.sin(obj.time * 3) * 0.01;
        if (obj.mesh.position.x < DESPAWN_X) {
          scene.remove(obj.mesh);
          items.splice(i, 1);
          continue;
        }
        const dx = obj.mesh.position.x - px;
        const dz = obj.mesh.position.z - pz;
        const dy = obj.mesh.position.y - py;
        const distSq = dx * dx + dz * dz + dy * dy;
        const hitDist = 0.9;
        if (distSq < hitDist * hitDist) {
          if (obj.type === 'heal') {
            healHP(20);
            showMessage('ã¡ã‚‡ã£ã¨å›å¾©ï¼');
          } else if (obj.type === 'star') {
            startInvincible();
          }
          score += 50;
          scene.remove(obj.mesh);
          items.splice(i, 1);
        }
      }

      // ãƒˆãƒ©ãƒƒãƒ—ï¼ˆçŸ¢å°åºŠãƒ»ãƒ­ã‚¤ã‚¿ãƒ¼æ¿ãƒ»ç©´ï¼‰
      for (let i = traps.length - 1; i >= 0; i--) {
        const obj = traps[i];
        obj.mesh.position.x -= speed * dt;
        if (obj.mesh.position.x < DESPAWN_X) {
          scene.remove(obj.mesh);
          traps.splice(i, 1);
          continue;
        }

        const dx = obj.mesh.position.x - px;
        const dz = obj.mesh.position.z - pz;
        const withinX = Math.abs(dx) < 0.8;
        const sameLane = Math.abs(dz) < 0.7;

        if (withinX && sameLane) {
          if (obj.type === 'arrow') {
            const dir = obj.mesh.userData.arrowDir || 0;
            if (dir !== 0) {
              const next = targetLane + dir;
              if (next >= 0 && next < LANE_COUNT) {
                targetLane = next;
              }
            }
          } else if (obj.type === 'spring') {
            // ãƒ­ãƒ³ã‚°ã‚¸ãƒ£ãƒ³ãƒ—ç™ºå‹•ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ä¸­ã§ã‚‚ä¸Šæ›¸ãï¼‰
            verticalVelocity = longJumpVelocity;
            isJumping = true;
          } else if (obj.type === 'hole') {
            if (!isJumping && py <= GROUND_Y + 0.05) {
              triggerInstantDeath('ç©´ã«è½ã¡ã¦ã—ã¾ã£ãŸâ€¦');
            }
          }
        }
      }

      // ç„¡æ•µçŠ¶æ…‹ã®æ›´æ–°
      updateInvincible(dt);

      // ã‚¹ã‚³ã‚¢åŠ ç®—ï¼ˆç”Ÿå­˜æ™‚é–“ï¼‰
      score += dt * 10;

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒãƒ¼
      if (messageTimer > 0) {
        messageTimer -= dt;
        if (messageTimer <= 0) {
          messageTextEl.style.opacity = '0';
        }
      }

      updateUI();
    }

    // ================================
    //  ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    // ================================
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (gameState === 'playing') {
        update(dt);
      }
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    // ================================
    //  èµ·å‹•
    // ================================
    init();
  </script>
</body>
</html>
