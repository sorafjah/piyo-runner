<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            background-color: #87CEEB; /* ç©ºã®è‰² */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UIãƒ¬ã‚¤ãƒ¤ãƒ¼ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* ã‚²ãƒ¼ãƒ æ“ä½œã‚’é˜»å®³ã—ãªã„ */
        }

        /* å·¦ä¸Šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
        #status-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #lives {
            font-size: 24px;
        }

        #hp-container {
            width: 200px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background-color: #ff6b6b;
            transition: width 0.2s;
        }

        /* å³ä¸Šã‚¹ã‚³ã‚¢ */
        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }

        /* ä¸­å¤®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ãƒ»ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰ */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* ãƒœã‚¿ãƒ³æŠ¼ä¸‹ã®ãŸã‚ */
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 4px 4px 0px #ff6b6b;
            margin: 0 0 20px 0;
        }

        .instructions {
            color: white;
            font-size: 18px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #2E7D32;
            transition: transform 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }

        /* ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: red;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.1s;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    <div id="damage-flash"></div>

    <div id="ui-layer">
        <div id="status-bar">
            <div id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
            <div id="hp-container">
                <div id="hp-bar"></div>
            </div>
        </div>
        <div id="score-board">0</div>
    </div>

    <div id="overlay">
        <h1 id="title-text">ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼</h1>
        <div class="instructions" id="instructions">
            ğŸ‘† ã‚¿ãƒƒãƒ—ï¼šã‚¸ãƒ£ãƒ³ãƒ—<br>
            â†•ï¸ ä¸Šä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—ï¼šãƒ¬ãƒ¼ãƒ³ç§»å‹•<br>
            <br>
            éšœå®³ç‰©ã‚’é¿ã‘ã¦èµ°ã‚Šç¶šã‘ã‚ˆã†ï¼
        </div>
        <div class="instructions hidden" id="result-area">
            SCORE: <span id="final-score">0</span>
        </div>
        <button id="start-btn">START</button>
    </div>

<script>
/**
 * ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼ - ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * æ§‹æˆ:
 * 1. Constants & Globals: å®šæ•°ã¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
 * 2. Setup: Three.jsã®åˆæœŸåŒ–
 * 3. Classes:
 * - Piyo (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼)
 * - World (åºŠã€èƒŒæ™¯)
 * - ObjectManager (éšœå®³ç‰©ã€ã‚¢ã‚¤ãƒ†ãƒ ç®¡ç†)
 * - InputManager (ã‚¿ãƒƒãƒæ“ä½œ)
 * 4. Game Loop: ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã¨ãƒ­ã‚¸ãƒƒã‚¯
 */

// --- 1. Constants & Globals ---

const COLORS = {
    SKY: 0x87CEEB,
    GROUND_A: 0xFFF0F5, // è–„ãƒ”ãƒ³ã‚¯
    GROUND_B: 0xE6E6FA, // è–„ç´«
    HOLE: 0x222222,
    PIYO_BODY: 0xFFD700,
    PIYO_BEAK: 0xFFA500,
    SPIKE: 0xFF6B6B,
    BEE: 0xFFCC00,
    BOMB: 0x333333,
    HEART: 0xFF69B4,
    STAR: 0xFFFF00,
    ARROW_FLOOR: 0x00BFFF,
    SPRING_FLOOR: 0xFFFFE0 // è–„ã„é»„è‰²
};

const GAME_CONFIG = {
    LANE_COUNT: 4,
    LANE_WIDTH: 2.5,
    TILE_SIZE: 3,
    START_SPEED: 0.2,
    MAX_SPEED: 0.6,
    GRAVITY: 0.03,
    JUMP_FORCE: 0.5,
    LONG_JUMP_FORCE: 0.9,
    INVINCIBLE_TIME: 300, // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
};

// ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ç®¡ç†
let gameState = {
    isPlaying: false,
    speed: GAME_CONFIG.START_SPEED,
    score: 0,
    lives: 3,
    hp: 100,
    distance: 0,
    frameCount: 0
};

// Three.js ã‚°ãƒ­ãƒ¼ãƒãƒ«
let scene, camera, renderer;
let piyo, world, objectManager, inputManager;

// --- 2. Setup ---

function init() {
    // ã‚·ãƒ¼ãƒ³ä½œæˆ
    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.SKY);
    scene.fog = new THREE.Fog(COLORS.SKY, 20, 60);

    // ã‚«ãƒ¡ãƒ©è¨­å®š (ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼ãƒ“ãƒ¥ãƒ¼)
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ x=-5 ã‚ãŸã‚Šã«ã„ã‚‹æƒ³å®šã€‚
    // å³å¥¥ã‹ã‚‰å·¦æ‰‹å‰ã¸æµã‚Œã‚‹æ¼”å‡ºã®ãŸã‚ã€ã‚«ãƒ¡ãƒ©ã‚’ã‚„ã‚„æ–œã‚ã«é…ç½®
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(-8, 12, 12); 
    camera.lookAt(5, 0, 0);

    // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š
    const container = document.getElementById('game-container');
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // å„ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
    world = new World();
    piyo = new Piyo();
    objectManager = new ObjectManager();
    inputManager = new InputManager();

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    window.addEventListener('resize', onWindowResize, false);
    document.getElementById('start-btn').addEventListener('click', startGame);

    // ãƒ«ãƒ¼ãƒ—é–‹å§‹
    animate();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- 3. Classes ---

/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆã²ã‚ˆã“ï¼‰ã‚¯ãƒ©ã‚¹
 */
class Piyo {
    constructor() {
        this.mesh = new THREE.Group();
        
        // ä½“
        const bodyGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const bodyMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_BODY });
        this.body = new THREE.Mesh(bodyGeo, bodyMat);
        this.body.castShadow = true;
        this.mesh.add(this.body);

        // ãã¡ã°ã—
        const beakGeo = new THREE.ConeGeometry(0.2, 0.4, 8);
        const beakMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_BEAK });
        this.beak = new THREE.Mesh(beakGeo, beakMat);
        this.beak.rotation.z = -Math.PI / 2;
        this.beak.position.set(0.7, 0, 0);
        this.mesh.add(this.beak);

        // ç›®
        const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        this.eyeL = new THREE.Mesh(eyeGeo, eyeMat);
        this.eyeL.position.set(0.6, 0.2, 0.3);
        this.eyeR = new THREE.Mesh(eyeGeo, eyeMat);
        this.eyeR.position.set(0.6, 0.2, -0.3);
        this.mesh.add(this.eyeL);
        this.mesh.add(this.eyeR);

        scene.add(this.mesh);

        // çŠ¶æ…‹
        this.lane = 1; // 0~3
        this.targetZ = this.getZFromLane(this.lane);
        this.mesh.position.set(-4, 1, this.targetZ);
        
        this.yVelocity = 0;
        this.isJumping = false;
        this.invincibleTimer = 0;
        this.flashTimer = 0;
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
        this.bounceOffset = 0;
    }

    getZFromLane(lane) {
        // ãƒ¬ãƒ¼ãƒ³0ãŒå¥¥(-Z)ã€ãƒ¬ãƒ¼ãƒ³3ãŒæ‰‹å‰(+Z)
        // ä¸­å¿ƒã‚’0ã¨ã—ã¦é…ç½®
        const centerOffset = (GAME_CONFIG.LANE_COUNT - 1) * GAME_CONFIG.LANE_WIDTH / 2;
        return (lane * GAME_CONFIG.LANE_WIDTH) - centerOffset;
    }

    reset() {
        this.lane = 1; // åˆæœŸãƒ¬ãƒ¼ãƒ³
        this.mesh.position.set(-4, 1, this.getZFromLane(this.lane));
        this.yVelocity = 0;
        this.isJumping = false;
        this.invincibleTimer = 0;
        this.mesh.visible = true;
        this.body.material.color.setHex(COLORS.PIYO_BODY);
    }

    moveLane(direction) {
        if (!gameState.isPlaying) return;
        this.lane += direction;
        // ç¯„å›²åˆ¶é™
        if (this.lane < 0) this.lane = 0;
        if (this.lane >= GAME_CONFIG.LANE_COUNT) this.lane = GAME_CONFIG.LANE_COUNT - 1;
    }

    jump(forceType = 'normal') {
        if (!gameState.isPlaying) return;
        if (!this.isJumping) {
            this.isJumping = true;
            this.yVelocity = forceType === 'long' ? GAME_CONFIG.LONG_JUMP_FORCE : GAME_CONFIG.JUMP_FORCE;
        }
    }

    forceMoveLane(direction) {
        this.moveLane(direction);
    }

    damage(amount) {
        if (this.invincibleTimer > 0) return; // ç„¡æ•µä¸­

        gameState.hp -= amount;
        updateUI();

        // ãƒ€ãƒ¡ãƒ¼ã‚¸æ¼”å‡º
        flashScreen();
        this.flashTimer = 20;

        if (gameState.hp <= 0) {
            gameState.lives--;
            gameState.hp = 100;
            updateUI();
            if (gameState.lives <= 0) {
                gameOver();
            }
        }
    }

    heal(amount) {
        gameState.hp = Math.min(100, gameState.hp + amount);
        updateUI();
        // å…‰ã‚‹æ¼”å‡ºï¼ˆç°¡æ˜“ï¼‰
        this.body.material.emissive.setHex(0x555555);
        setTimeout(() => { this.body.material.emissive.setHex(0x000000); }, 200);
    }

    setInvincible() {
        this.invincibleTimer = GAME_CONFIG.INVINCIBLE_TIME;
        gameState.speed += 0.05; // å°‘ã—åŠ é€Ÿ
    }

    die() {
        gameState.lives = 0;
        gameState.hp = 0;
        updateUI();
        gameOver();
    }

    update() {
        // Xåº§æ¨™ã¯å›ºå®šã€Zåº§æ¨™ï¼ˆãƒ¬ãƒ¼ãƒ³ï¼‰ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«ç§»å‹•
        this.targetZ = this.getZFromLane(this.lane);
        this.mesh.position.z += (this.targetZ - this.mesh.position.z) * 0.2;

        // ã‚¸ãƒ£ãƒ³ãƒ— & é‡åŠ›
        if (this.isJumping) {
            this.mesh.position.y += this.yVelocity;
            this.yVelocity -= GAME_CONFIG.GRAVITY;

            // ç€åœ°åˆ¤å®š (Y < 1 ã§ç€åœ°ã¨ã¿ãªã™)
            // ç©´ã®ä¸Šã«ã„ã‚‹å ´åˆã¯ç€åœ°ã—ãªã„åˆ¤å®šãŒå¿…è¦ã ãŒã€
            // ç°¡æ˜“çš„ã«ã“ã“ã§ã¯åœ°é¢é«˜ã•(1)ã§åˆ¤å®šã—ã€Collisionå´ã§ç©´åˆ¤å®šã‚’è¡Œã†
            if (this.mesh.position.y <= 1 && !this.onHole) {
                this.mesh.position.y = 1;
                this.isJumping = false;
                this.yVelocity = 0;
            }
        } else {
            // èµ°ã£ã¦ã„ã‚‹æ™‚ã®ä¸Šä¸‹æºã‚Œ
            this.bounceOffset += 0.2;
            if (!this.onHole) {
                this.mesh.position.y = 1 + Math.abs(Math.sin(this.bounceOffset)) * 0.2;
            } else {
                // ç©´ã«è½ã¡ã‚‹
                this.mesh.position.y -= 0.5;
                if (this.mesh.position.y < -5) {
                    this.die();
                }
            }
        }

        // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆèµ°ã£ã¦ã‚‹æ„Ÿï¼‰
        if (!this.onHole) {
            this.body.rotation.z -= 0.1;
        }

        // ç„¡æ•µã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        if (this.invincibleTimer > 0) {
            this.invincibleTimer--;
            // ç‚¹æ»… or è‰²å¤‰åŒ–
            if (this.invincibleTimer % 10 < 5) {
                this.body.material.color.setHex(COLORS.STAR);
            } else {
                this.body.material.color.setHex(COLORS.PIYO_BODY);
            }
            // çµ‚äº†æ™‚
            if (this.invincibleTimer === 0) {
                this.body.material.color.setHex(COLORS.PIYO_BODY);
                gameState.speed = Math.max(GAME_CONFIG.START_SPEED, gameState.speed - 0.05);
            }
        }

        // ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ»…
        if (this.flashTimer > 0) {
            this.flashTimer--;
            this.mesh.visible = (this.flashTimer % 4 < 2);
        } else {
            this.mesh.visible = true;
        }
    }
}

/**
 * åœ°é¢ã¨èƒŒæ™¯ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
class World {
    constructor() {
        this.tiles = [];
        this.tileGroup = new THREE.Group();
        scene.add(this.tileGroup);

        // èƒŒæ™¯ã®å±±ãªã©
        this.sceneryGroup = new THREE.Group();
        scene.add(this.sceneryGroup);
        this.setupScenery();

        // åºŠã®ç”Ÿæˆ (20åˆ— x 4ãƒ¬ãƒ¼ãƒ³)
        this.cols = 24;
        for (let x = 0; x < this.cols; x++) {
            for (let z = 0; z < GAME_CONFIG.LANE_COUNT; z++) {
                this.createTile(x, z);
            }
        }
    }

    setupScenery() {
        // ç°¡æ˜“çš„ãªå±±ã‚„é›²ã‚’é…ç½®
        for(let i=0; i<10; i++) {
            const geo = new THREE.ConeGeometry(5 + Math.random()*5, 10 + Math.random()*10, 4);
            const mat = new THREE.MeshLambertMaterial({color: 0x88CC88});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(
                Math.random() * 100 - 20,
                -5,
                -15 - Math.random() * 20 // å¥¥ã®æ–¹
            );
            this.sceneryGroup.add(mesh);
        }
    }

    createTile(gridX, laneIndex) {
        const size = GAME_CONFIG.TILE_SIZE;
        const geo = new THREE.BoxGeometry(size, 1, GAME_CONFIG.LANE_WIDTH - 0.1);
        
        // å¸‚æ¾æ¨¡æ§˜çš„ãªè‰²åˆ†ã‘
        const isEven = (gridX + laneIndex) % 2 === 0;
        const color = isEven ? COLORS.GROUND_A : COLORS.GROUND_B;
        
        const mat = new THREE.MeshLambertMaterial({ color: color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.receiveShadow = true;

        // åˆæœŸä½ç½®è¨ˆç®—
        const z = (laneIndex * GAME_CONFIG.LANE_WIDTH) - ((GAME_CONFIG.LANE_COUNT - 1) * GAME_CONFIG.LANE_WIDTH / 2);
        // xã¯æ‰‹å‰(-X)ã‹ã‚‰å¥¥(+X)ã¸ã€ã¨è¨€ã„ãŸã„ã¨ã“ã‚ã ãŒã€
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ-Xã«å‘ã‹ã£ã¦èµ°ã‚‹(ä¸–ç•ŒãŒ+Xã‹ã‚‰-Xã¸æµã‚Œã‚‹)ã®ã§
        // ã‚°ãƒªãƒƒãƒ‰0ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å°‘ã—å¾Œã‚ã€ã‚°ãƒªãƒƒãƒ‰Nã¯ç”»é¢å³å¥¥
        const xStart = -10; 
        const x = xStart + gridX * size;

        mesh.position.set(x, -0.5, z);

        const tileData = {
            mesh: mesh,
            gridX: gridX, // è«–ç†çš„ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            lane: laneIndex,
            type: 'normal', // normal, hole, arrow, spring
            active: true
        };
        
        mesh.userData = tileData;
        this.tiles.push(tileData);
        this.tileGroup.add(mesh);
    }

    reset() {
        // ã‚¿ã‚¤ãƒ«ã‚’åˆæœŸä½ç½®ã«æˆ»ã—ã€ã‚¿ã‚¤ãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.tiles.forEach(t => {
            const size = GAME_CONFIG.TILE_SIZE;
            const xStart = -10;
            t.mesh.position.x = xStart + t.gridX * size;
            this.resetTileType(t);
        });
    }

    resetTileType(tile) {
        tile.type = 'normal';
        tile.mesh.visible = true;
        tile.mesh.material.color.setHex((tile.gridX + tile.lane) % 2 === 0 ? COLORS.GROUND_A : COLORS.GROUND_B);
        // çŸ¢å°ç­‰ã®è£…é£¾ãŒã‚ã‚Œã°æ¶ˆã™(ç°¡æ˜“å®Ÿè£…ã®ãŸã‚è‰²ã§åˆ¤æ–­)
    }

    update() {
        const speed = gameState.speed;
        const size = GAME_CONFIG.TILE_SIZE;
        const limitX = -12; // ç”»é¢å·¦ç«¯ï¼ˆæ¶ˆãˆã‚‹ä½ç½®ï¼‰
        const respawnX = (this.cols * size) + limitX; // ç”»é¢å³ç«¯ï¼ˆå‡ºç¾ä½ç½®ï¼‰

        // èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
        this.sceneryGroup.position.x -= speed * 0.2;
        if(this.sceneryGroup.position.x < -50) this.sceneryGroup.position.x = 0;

        // ã‚¿ã‚¤ãƒ«ç§»å‹•
        this.tiles.forEach(tile => {
            tile.mesh.position.x -= speed;

            if (tile.mesh.position.x < limitX) {
                // ãƒªã‚µã‚¤ã‚¯ãƒ«
                tile.mesh.position.x += (this.cols * size);
                this.resetTileType(tile);
                
                // æ–°ã—ã„ã‚®ãƒŸãƒƒã‚¯ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½é¸
                // ä¸€ç•ªå³ã®åˆ—ï¼ˆ4ãƒ¬ãƒ¼ãƒ³åˆ†ï¼‰ãŒåŒæ™‚ã«æ›´æ–°ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ã€å€‹åˆ¥ã«æŠ½é¸
                // â€» æœ¬æ¥ã¯åˆ—å˜ä½ã§ç®¡ç†ã—ãŸã»ã†ãŒç”Ÿæˆåˆ¶å¾¡ã—ã‚„ã™ã„ãŒã€ä»Šå›ã¯ç°¡æ˜“çš„ã«å€‹åˆ¥ã«ç¢ºç‡ã§ç”Ÿæˆ
                objectManager.spawnObjectOnTile(tile);
            }
        });
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã®ä¸‹ã«ã‚ã‚‹ã‚¿ã‚¤ãƒ«ã®æƒ…å ±ã‚’å–å¾—
    getTileAt(x, z) {
        // x, zåº§æ¨™ã«æœ€ã‚‚è¿‘ã„ã‚¿ã‚¤ãƒ«ã‚’æ¢ã™ï¼ˆæœ€é©åŒ–å¯èƒ½ã ãŒå…¨æ¢ç´¢ã§å®Ÿè£…ï¼‰
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Xã¯å›ºå®š(-4)
        return this.tiles.find(t => 
            Math.abs(t.mesh.position.x - x) < GAME_CONFIG.TILE_SIZE / 2 &&
            Math.abs(t.mesh.position.z - z) < 0.5
        );
    }
}

/**
 * éšœå®³ç‰©ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ç®¡ç†ã‚¯ãƒ©ã‚¹
 */
class ObjectManager {
    constructor() {
        this.objects = []; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        this.pool = []; // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«
        this.objGroup = new THREE.Group();
        scene.add(this.objGroup);
    }

    reset() {
        this.objects.forEach(o => {
            o.mesh.visible = false;
            this.pool.push(o);
        });
        this.objects = [];
    }

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¯ãƒˆãƒª
    createMesh(type) {
        let mesh;
        if (type === 'spike') {
            mesh = new THREE.Group();
            const core = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshLambertMaterial({color: COLORS.SPIKE}));
            mesh.add(core);
            // ãƒˆã‚²
            for(let i=0; i<6; i++) {
                const cone = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.6, 8), new THREE.MeshLambertMaterial({color: COLORS.SPIKE}));
                cone.position.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.4);
                cone.lookAt(0,0,0);
                mesh.add(cone);
            }
        } else if (type === 'bee') {
            mesh = new THREE.Group();
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshLambertMaterial({color: COLORS.BEE}));
            mesh.add(body);
            // ç¾½ï¼ˆå›è»¢ã•ã›ã‚‹ï¼‰
            const wing = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.2), new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.8}));
            wing.position.y = 0.3;
            wing.rotation.x = Math.PI/2;
            mesh.add(wing);
            mesh.userData.wing = wing;
        } else if (type === 'bomb') {
            mesh = new THREE.Group();
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshLambertMaterial({color: COLORS.BOMB}));
            const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshBasicMaterial({color: 0x888888}));
            fuse.position.y = 0.4;
            mesh.add(body);
            mesh.add(fuse);
        } else if (type === 'heart') {
            // ç°¡æ˜“ãƒãƒ¼ãƒˆï¼ˆ2ã¤ã®çƒï¼‰
            mesh = new THREE.Group();
            const m = new THREE.MeshLambertMaterial({color: COLORS.HEART});
            const s1 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), m);
            s1.position.x = -0.2;
            const s2 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), m);
            s2.position.x = 0.2;
            mesh.add(s1);
            mesh.add(s2);
        } else if (type === 'star') {
            // ç°¡æ˜“æ˜Ÿï¼ˆæ­£å…«é¢ä½“ï¼‰
            mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.4, 0), new THREE.MeshBasicMaterial({color: COLORS.STAR}));
        }
        
        if(mesh) {
            mesh.castShadow = true;
            this.objGroup.add(mesh);
        }
        return mesh;
    }

    spawnObjectOnTile(tile) {
        // ç¢ºç‡ã§ç”Ÿæˆ
        const rand = Math.random();
        
        // ç©´ç”Ÿæˆ (5%)
        if (rand < 0.05) {
            tile.type = 'hole';
            tile.mesh.visible = false; // è¦‹ãˆãªãã™ã‚‹ï¼ˆç©´ï¼‰
            return; 
        }

        // åºŠã‚®ãƒŸãƒƒã‚¯ (5%)
        if (rand < 0.10) {
            const type = Math.random() < 0.5 ? 'arrow' : 'spring';
            tile.type = type;
            tile.mesh.material.color.setHex(type === 'arrow' ? COLORS.ARROW_FLOOR : COLORS.SPRING_FLOOR);
            // çŸ¢å°æ–¹å‘ã¯ãƒ©ãƒ³ãƒ€ãƒ 
            if (type === 'arrow') {
                tile.arrowDir = Math.random() < 0.5 ? 1 : -1;
                // ç«¯ã®å ´åˆã¯å†…å´ã¸
                if (tile.lane === 0) tile.arrowDir = 1;
                if (tile.lane === GAME_CONFIG.LANE_COUNT-1) tile.arrowDir = -1;
            }
            return;
        }

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ (15% æ•µ, 5% ã‚¢ã‚¤ãƒ†ãƒ )
        let type = null;
        if (rand < 0.20) {
            // æ•µ
            const r2 = Math.random();
            if (r2 < 0.4) type = 'spike';
            else if (r2 < 0.7) type = 'bee';
            else type = 'bomb';
        } else if (rand < 0.25) {
            // ã‚¢ã‚¤ãƒ†ãƒ 
            // HPãƒ”ãƒ³ãƒãªã‚‰å›å¾©å‡ºã‚„ã™ã
            const needHeal = gameState.hp <= 30;
            if (needHeal && Math.random() < 0.7) type = 'heart';
            else type = Math.random() < 0.7 ? 'heart' : 'star';
        }

        if (!type) return;

        // ãƒ—ãƒ¼ãƒ«ã‹ã‚‰å–å¾—ã¾ãŸã¯æ–°è¦ä½œæˆ
        let objData = this.pool.find(o => !o.active && o.type === type);
        if (!objData) {
            objData = {
                mesh: this.createMesh(type),
                type: type,
                active: false
            };
            this.objects.push(objData); // ç®¡ç†ãƒªã‚¹ãƒˆã¸
        } else {
            // ãƒ—ãƒ¼ãƒ«ã‹ã‚‰é™¤å¤–
            this.pool = this.pool.filter(o => o !== objData);
            this.objects.push(objData);
        }

        // åˆæœŸåŒ–
        objData.active = true;
        objData.mesh.visible = true;
        
        // ä½ç½®åˆã‚ã›
        objData.mesh.position.x = tile.mesh.position.x;
        objData.mesh.position.z = tile.mesh.position.z;
        
        // é«˜ã•è¨­å®š
        if (type === 'bee') {
            objData.mesh.position.y = 2.5; // ç©ºä¸­
            objData.oscillation = Math.random() * Math.PI; // ä¸Šä¸‹ã®ã‚†ã‚‰ãç”¨ä½ç›¸
        } else if (type === 'bomb') {
            objData.mesh.position.y = 0.5; // åœ°é¢è»¢ãŒã‚‹
        } else {
            objData.mesh.position.y = 0.5; // åœ°é¢
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã¯å°‘ã—æµ®ã‹ã›ã‚‹
        if (type === 'heart' || type === 'star') {
            objData.mesh.position.y = 1.0;
        }
    }

    update() {
        const speed = gameState.speed;
        // æ›´æ–°ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            
            // ç§»å‹•
            obj.mesh.position.x -= speed;

            // å€‹åˆ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (obj.type === 'spike' || obj.type === 'bomb') {
                obj.mesh.rotation.z += 0.1; // è»¢ãŒã‚‹
            } else if (obj.type === 'bee') {
                obj.oscillation += 0.1;
                obj.mesh.position.y = 2.5 + Math.sin(obj.oscillation) * 0.5; // ä¸Šä¸‹ç§»å‹•
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã¥ãæ¨ªç§»å‹•ï¼ˆç°¡æ˜“ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ï¼‰
                if (obj.mesh.position.x > piyo.mesh.position.x) {
                   const dz = piyo.mesh.position.z - obj.mesh.position.z;
                   if (Math.abs(dz) < 3) obj.mesh.position.z += dz * 0.02;
                }
                // ç¾½ã°ãŸã
                if (obj.mesh.userData.wing) obj.mesh.userData.wing.rotation.z += 1;
            } else if (obj.type === 'heart' || obj.type === 'star') {
                obj.mesh.rotation.y += 0.05;
            }

            // ç”»é¢å¤–ã¸æ¶ˆãˆãŸã‚‰ãƒ—ãƒ¼ãƒ«ã¸
            if (obj.mesh.position.x < -15) {
                this.deactivate(obj, i);
            }
        }
    }

    deactivate(obj, index) {
        obj.active = false;
        obj.mesh.visible = false;
        this.objects.splice(index, 1);
        this.pool.push(obj);
    }

    checkCollision(player) {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ¤å®šãƒœãƒƒã‚¯ã‚¹ï¼ˆç°¡æ˜“: ä¸­å¿ƒè·é›¢ï¼‰
        const pPos = player.mesh.position;
        const hitDist = 0.8; // å½“ãŸã‚Šåˆ¤å®šåŠå¾„

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã®è¡çª
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            const dx = pPos.x - obj.mesh.position.x;
            const dy = pPos.y - obj.mesh.position.y;
            const dz = pPos.z - obj.mesh.position.z;
            
            // Xè»¸è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆé«˜é€ŸåŒ–ã®ãŸã‚ï¼‰
            if (Math.abs(dx) > 1.0) continue;

            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            if (dist < hitDist) {
                this.resolveCollision(player, obj, i);
            }
        }
    }

    resolveCollision(player, obj, index) {
        const type = obj.type;

        // ã‚¢ã‚¤ãƒ†ãƒ ç³»ã¯å–å¾—ã—ãŸã‚‰æ¶ˆãˆã‚‹
        if (type === 'heart') {
            player.heal(20);
            this.deactivate(obj, index);
        } else if (type === 'star') {
            player.setInvincible();
            this.deactivate(obj, index);
        } else {
            // æ•µãƒ»éšœå®³ç‰©ï¼ˆç„¡æ•µãªã‚‰ç„¡è¦–ï¼‰
            if (player.invincibleTimer > 0) return;

            if (type === 'spike') {
                player.damage(20);
                this.deactivate(obj, index); // å½“ãŸã£ãŸã‚‰æ¶ˆã™ï¼ˆã¾ãŸã¯é€šã‚ŠæŠœã‘ã‚‹ï¼‰
            } else if (type === 'bee') {
                player.damage(20);
                this.deactivate(obj, index);
            } else if (type === 'bomb') {
                player.die();
                this.deactivate(obj, index);
            }
        }
    }
}

/**
 * å…¥åŠ›ç®¡ç†ã‚¯ãƒ©ã‚¹
 */
class InputManager {
    constructor() {
        this.startX = 0;
        this.startY = 0;
        this.isTouching = false;

        document.addEventListener('touchstart', this.onTouchStart.bind(this), {passive: false});
        document.addEventListener('touchmove', this.onTouchMove.bind(this), {passive: false});
        document.addEventListener('touchend', this.onTouchEnd.bind(this), {passive: false});
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒã‚¦ã‚¹æ“ä½œ
        document.addEventListener('mousedown', this.onMouseDown.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));
    }

    onTouchStart(e) {
        // UIã‚¿ãƒƒãƒ—ã¯é™¤å¤–ã—ãŸã„ãŒã€ä»Šå›ã¯å…¨ç”»é¢ã§å–ã‚‹
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isTouching = true;
    }

    onTouchMove(e) {
        if (!this.isTouching) return;
        // ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã®åŸºæœ¬
        e.preventDefault(); 
    }

    onTouchEnd(e) {
        if (!this.isTouching) return;
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        this.handleGesture(this.startX, this.startY, endX, endY);
        this.isTouching = false;
    }

    // PCãƒ‡ãƒãƒƒã‚°ç”¨
    onMouseDown(e) {
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.isTouching = true;
    }
    onMouseUp(e) {
        if (!this.isTouching) return;
        this.handleGesture(this.startX, this.startY, e.clientX, e.clientY);
        this.isTouching = false;
    }

    handleGesture(x1, y1, x2, y2) {
        if (!gameState.isPlaying) return;

        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 30) {
            // ã‚¿ãƒƒãƒ—ã¨ã¿ãªã™ -> ã‚¸ãƒ£ãƒ³ãƒ—
            piyo.jump();
        } else {
            // ã‚¹ãƒ¯ã‚¤ãƒ—
            if (Math.abs(dy) > Math.abs(dx)) {
                // ç¸¦ã‚¹ãƒ¯ã‚¤ãƒ—
                if (dy > 0) {
                    // ä¸‹æ–¹å‘ã‚¹ãƒ¯ã‚¤ãƒ—ï¼ˆç”»é¢æ‰‹å‰ã¸ï¼‰
                    piyo.moveLane(1);
                } else {
                    // ä¸Šæ–¹å‘ã‚¹ãƒ¯ã‚¤ãƒ—ï¼ˆç”»é¢å¥¥ã¸ï¼‰
                    piyo.moveLane(-1);
                }
            }
        }
    }
}

// --- 4. Game Loop & Logic ---

function startGame() {
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('result-area').classList.add('hidden');
    
    // ãƒªã‚»ãƒƒãƒˆ
    gameState.isPlaying = true;
    gameState.score = 0;
    gameState.lives = 3;
    gameState.hp = 100;
    gameState.speed = GAME_CONFIG.START_SPEED;
    gameState.distance = 0;
    gameState.frameCount = 0;

    piyo.reset();
    world.reset();
    objectManager.reset();
    
    updateUI();
}

function gameOver() {
    gameState.isPlaying = false;
    document.getElementById('overlay').classList.remove('hidden');
    document.getElementById('title-text').innerText = "GAME OVER";
    document.getElementById('instructions').classList.add('hidden'); // èª¬æ˜ã‚’éš ã™
    
    const resultArea = document.getElementById('result-area');
    resultArea.classList.remove('hidden');
    document.getElementById('final-score').innerText = Math.floor(gameState.score);
    
    document.getElementById('start-btn').innerText = "ã‚‚ã†ä¸€åº¦";
}

function updateUI() {
    // ãƒ©ã‚¤ãƒ•
    let heartStr = "";
    for(let i=0; i<gameState.lives; i++) heartStr += "â¤ï¸";
    document.getElementById('lives').innerText = heartStr;

    // HPãƒãƒ¼
    document.getElementById('hp-bar').style.width = gameState.hp + "%";

    // ã‚¹ã‚³ã‚¢
    document.getElementById('score-board').innerText = Math.floor(gameState.score);
}

function flashScreen() {
    const flash = document.getElementById('damage-flash');
    flash.style.opacity = 0.5;
    setTimeout(() => { flash.style.opacity = 0; }, 100);
}

// åºŠã‚®ãƒŸãƒƒã‚¯åˆ¤å®š
function checkTileGimmick() {
    if (piyo.isJumping && piyo.mesh.position.y > 1.5) return; // é«˜ãé£›ã‚“ã§ãŸã‚‰ç„¡è¦–

    const tile = world.getTileAt(piyo.mesh.position.x, piyo.mesh.position.z);
    
    if (tile) {
        piyo.onHole = (tile.type === 'hole');

        if (tile.type === 'hole') {
            // è½ä¸‹å‡¦ç†ã¯ piyo.update() å†…ã§è¡Œã‚ã‚Œã‚‹
        }
        else if (tile.type === 'arrow') {
            // å¼·åˆ¶ç§»å‹•
            piyo.forceMoveLane(tile.arrowDir);
            tile.type = 'normal'; // ä¸€å›ç™ºå‹•ã—ãŸã‚‰ç„¡åŠ¹åŒ–ï¼ˆãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
        }
        else if (tile.type === 'spring') {
            // ãƒ­ãƒ³ã‚°ã‚¸ãƒ£ãƒ³ãƒ—
            piyo.jump('long');
        }
    } else {
        piyo.onHole = false;
    }
}

function animate() {
    requestAnimationFrame(animate);

    if (gameState.isPlaying) {
        gameState.frameCount++;
        gameState.distance += gameState.speed;
        
        // ã‚¹ã‚³ã‚¢åŠ ç®— (è·é›¢ + ç”Ÿå­˜ãƒœãƒ¼ãƒŠã‚¹)
        if (gameState.frameCount % 10 === 0) {
            gameState.score += 1;
            updateUI();
        }

        // ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
        if (gameState.frameCount % 600 === 0) { // ç´„10ç§’ã”ã¨
            gameState.speed = Math.min(GAME_CONFIG.MAX_SPEED, gameState.speed + 0.02);
        }

        world.update();
        objectManager.update();
        piyo.update();
        
        checkTileGimmick();
        objectManager.checkCollision(piyo);
    } else {
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã§ã‚‚å°‘ã—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã›ã‚‹ã¨ä½™éŸ»ãŒã‚ã‚‹ãŒã€
        // ä»Šå›ã¯åœæ­¢
    }

    renderer.render(scene, camera);
}

// ã‚¹ã‚¿ãƒ¼ãƒˆ
init();

</script>
</body>
</html>
