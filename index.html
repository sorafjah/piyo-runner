<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#87CEEB">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="„Å¥„Çà„É©„É≥„Éä„Éº">
    <link rel="apple-touch-icon" href="QR_piyorunner.png">
    <link rel="icon" href="QR_piyorunner.png">
    
    <title>„Å¥„Çà„É©„É≥„Éä„Éº</title>
    <style>
        /* iOSÁâπÊúâ„ÅÆ„Éê„Ç¶„É≥„ÉâÔºà„É©„Éê„Éº„Éê„É≥„ÉâÔºâ„ÇíÂÆåÂÖ®„Å´Èò≤„ÅêË®≠ÂÆö */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: fixed;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            background-color: #333;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* „Ç≤„Éº„É†ÂÖ®‰Ωì„ÇíÂåÖ„ÇÄ„É©„ÉÉ„Éë„Éº */
        #game-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #87CEEB;
        }

        /* „Çπ„Éû„ÉõÁ∏¶ÊåÅ„Å°ÊôÇ„Å´Âº∑Âà∂ÁöÑ„Å´Ê®™ÁîªÈù¢„Å´„Åô„ÇãCSSÂ§âÂΩ¢ */
        @media screen and (orientation: portrait) {
            #game-wrapper {
                width: 100vh;
                height: 100vw;
                transform: rotate(90deg);
                transform-origin: top left;
                position: absolute;
                top: 0;
                left: 100vw;
            }
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #game-container canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* UI„É¨„Ç§„É§„Éº */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Â∑¶‰∏ä„Çπ„ÉÜ„Éº„Çø„Çπ */
        #status-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
        }

        #lives {
            font-size: 24px;
            letter-spacing: 5px;
        }

        #hp-container {
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background-color: #ff6b6b;
            transition: width 0.1s linear;
        }

        /* Âè≥‰∏ä„Çπ„Ç≥„Ç¢ */
        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0px rgba(0,0,0,0.5);
            padding-top: env(safe-area-inset-top);
            padding-right: env(safe-area-inset-right);
        }

        /* „Å∂„Å£„Å∂„Éº„É°„ÉÉ„Çª„Éº„Ç∏ */
        #bubbu-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 60px;
            font-weight: 900;
            color: #ff0000;
            text-shadow: 3px 3px 0 #fff, -1px -1px 0 #fff;
            white-space: nowrap;
            opacity: 0;
            z-index: 50;
            pointer-events: none;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s;
        }
        #bubbu-msg.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        /* ‰∏≠Â§Æ„É°„ÉÉ„Çª„Éº„Ç∏ & „É©„É≥„Ç≠„É≥„Ç∞ */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #ff6b6b;
            margin: 0 0 10px 0;
        }

        .instructions {
            color: white;
            font-size: 16px;
            text-align: center;
            line-height: 1.8;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.5); 
            padding: 15px;
            border-radius: 10px;
            min-width: 280px;
        }

        /* ÈÄüÂ∫¶ÈÅ∏Êäû„Ç®„É™„Ç¢ */
        .speed-select-area {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            color: white;
        }
        .speed-options {
            display: flex;
            gap: 15px;
            margin-top: 5px;
            justify-content: center;
        }
        .speed-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 18px;
            background: rgba(0,0,0,0.3);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid transparent;
        }
        /* „É©„Ç∏„Ç™„Éú„Çø„É≥„ÅØÈö†„Åó„Å¶Ë¶ã„ÅüÁõÆ„ÇíCSS„Åß‰Ωú„Çã */
        .speed-label input {
            display: none;
        }
        .speed-label:has(input:checked) {
            background: #FFD700;
            color: #333;
            border-color: #fff;
            font-weight: bold;
        }

        /* „É©„É≥„Ç≠„É≥„Ç∞„Éú„Éº„Éâ */
        #ranking-board {
            background: rgba(255, 255, 255, 0.9);
            width: 80%;
            max-width: 500px;
            max-height: 50vh; /* ÁîªÈù¢„ÅÆÂçäÂàÜ„Åè„Çâ„ÅÑ„Åæ„Åß */
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-y: auto; /* „Çπ„ÇØ„É≠„Éº„É´ÂèØËÉΩ„Å´ */
            color: #333;
            font-size: 14px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            -webkit-overflow-scrolling: touch; /* iOS„Åß„ÅÆ„Çπ„ÇØ„É≠„Éº„É´Êªë„Çâ„ÅãÂåñ */
        }

        #ranking-board h2 {
            text-align: center;
            margin: 0 0 10px 0;
            color: #2E7D32;
            border-bottom: 2px solid #2E7D32;
            padding-bottom: 5px;
        }

        .rank-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .rank-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid #ddd;
        }
        .rank-item:last-child {
            border-bottom: none;
        }
        
        /* Ëá™ÂàÜ„ÅÆ‰ªäÂõû„ÅÆ„Çπ„Ç≥„Ç¢„ÇíÂº∑Ë™ø */
        .rank-item.current-score {
            background-color: #FFD700;
            font-weight: bold;
            border-radius: 5px;
        }
        
        .rank-rank { width: 50px; font-weight: bold; }
        .rank-score { flex: 1; text-align: right; font-family: monospace; font-size: 16px; }
        .rank-date { width: 100px; text-align: right; font-size: 10px; color: #666; margin-left: 10px; line-height: 20px;}

        .btn-group {
            display: flex;
            gap: 20px;
        }

        button {
            padding: 12px 30px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            border-bottom: 4px solid #2E7D32; 
            transition: transform 0.1s;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        button:active {
            transform: translateY(4px);
            border-bottom: none;
            margin-top: 4px;
        }

        button.sound-off {
            background-color: #757575;
            border-bottom: 4px solid #424242;
        }

        .hidden {
            display: none !important;
        }

        /* „ÉÄ„É°„Éº„Ç∏„Ç®„Éï„Çß„ÇØ„Éà */
        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.4);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.1s;
        }
        
        /* „Ç®„Éï„Çß„ÇØ„Éà„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        #effect-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            opacity: 0;
            transition: opacity 0.3s;
            background: transparent;
            will-change: opacity, background-color; 
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-wrapper">
        <div id="game-container"></div>
        <div id="damage-flash"></div>
        <div id="effect-overlay"></div>

        <div id="ui-layer">
            <div id="status-bar">
                <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div id="hp-container">
                    <div id="hp-bar"></div>
                </div>
            </div>
            <div id="score-board">0</div>
            <div id="bubbu-msg">„Å∂„Å£„Å∂„Éº</div>
        </div>

        <div id="overlay">
            <h1 id="title-text">„Å¥„Çà„É©„É≥„Éä„Éº</h1>
            
            <div class="instructions" id="instructions">
                üëÜ „Çø„ÉÉ„ÉóÔºö„Ç∏„É£„É≥„Éó<br>
                ‚ÜîÔ∏è „Çπ„ÉØ„Ç§„ÉóÔºö„É¨„Éº„É≥ÁßªÂãï<br>
                üçô „Åä„Å´„Åé„ÇäÔºö‰ΩìÂäõÂõûÂæ©
            </div>

            <div class="speed-select-area" id="speed-selector">
                <div>„Çπ„Éî„Éº„ÉâÈÅ∏Êäû</div>
                <div class="speed-options">
                    <label class="speed-label">
                        <input type="radio" name="speed" value="low" checked> üî∞„ÇÜ„Å£„Åè„Çä
                    </label>
                    <label class="speed-label">
                        <input type="radio" name="speed" value="high"> üöÄ„ÅØ„ÇÑ„ÅÑ
                    </label>
                </div>
            </div>

            <div id="ranking-board" class="hidden">
                <h2>RANKING (TOP 100)</h2>
                <ul id="ranking-list" class="rank-list">
                    </ul>
            </div>

            <div class="instructions hidden" id="result-area">
                SCORE: <span id="final-score">0</span>
            </div>

            <div class="btn-group" id="start-buttons">
                <button id="start-sound-on">Èü≥„ÅÇ„Çä„ÅßSTART</button>
                <button id="start-sound-off" class="sound-off">Èü≥„Å™„Åó</button>
            </div>
            <button id="retry-btn" class="hidden">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
        </div>
    </div>

<script>
// --- Service Worker Registration for PWA ---
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
            .then(registration => {
                console.log('SW registered:', registration);
            })
            .catch(error => {
                console.log('SW registration failed:', error);
            });
    });
}

window.onerror = function(message, source, lineno, colno, error) {
    console.error(message, error);
};

// --- Áí∞Â¢ÉÂà§ÂÆö ---
const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const IS_STANDALONE = window.navigator.standalone || (window.matchMedia('(display-mode: standalone)').matches);

// --- 1. Sound Manager ---
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = false;
        this.masterGain = null;
    }

    init(enabled) {
        this.enabled = enabled;
        if (!enabled) return;
        
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; 
        this.masterGain.connect(this.ctx.destination);
    }

    playTone(type) {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.masterGain);

        const now = this.ctx.currentTime;

        switch (type) {
            case 'jump':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'coin': 
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.05);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'powerup': 
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            case 'damage':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
                break;
            case 'slow':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
                break;
        }
    }
}
const soundManager = new SoundManager();

// --- 2. Ranking Manager ---
class RankingManager {
    constructor() {
        this.storageKey = 'piyo_runner_v1_ranking';
        this.limit = 100;
    }

    load() {
        try {
            const data = localStorage.getItem(this.storageKey);
            return data ? JSON.parse(data) : [];
        } catch (e) {
            console.error("Ranking load error", e);
            return [];
        }
    }

    save(score) {
        let ranks = this.load();
        const now = new Date();
        const dateStr = `${now.getMonth()+1}/${now.getDate()} ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
        
        // Êñ∞„Åó„ÅÑ„Çπ„Ç≥„Ç¢„ÇíËøΩÂä†
        const newEntry = {
            score: Math.floor(score),
            date: dateStr,
            id: Date.now() // „É¶„Éã„Éº„ÇØIDÔºà‰ªäÂõûËøΩÂä†„Åó„Åü„Çπ„Ç≥„Ç¢„ÇíÁâπÂÆö„Åô„Çã„Åü„ÇÅÔºâ
        };
        ranks.push(newEntry);

        // „Çπ„Ç≥„Ç¢ÈôçÈ†Ü„ÇΩ„Éº„Éà
        ranks.sort((a, b) => b.score - a.score);

        // ‰∏ä‰Ωç100‰ª∂„Å´Áµû„Çã
        if (ranks.length > this.limit) {
            ranks = ranks.slice(0, this.limit);
        }

        // ‰øùÂ≠ò
        localStorage.setItem(this.storageKey, JSON.stringify(ranks));

        // ‰ªäÂõû„ÅÆÈ†Ü‰Ωç„Å®„É™„Çπ„Éà„ÇíËøî„Åô
        const myRank = ranks.findIndex(r => r.id === newEntry.id) + 1;
        
        // 100‰ΩçÂúèÂ§ñ„Å™„Çâ„É©„É≥„ÇØ0„ÇíËøî„Åô
        return {
            myRank: myRank > 0 ? myRank : -1,
            list: ranks,
            currentId: newEntry.id
        };
    }
}
const rankingManager = new RankingManager();


// --- 3. Constants & Globals ---

const COLORS = {
    SKY: 0x87CEEB,
    GROUND_A: 0xA8E6A1, 
    GROUND_B: 0x66C97F, 
    HOLE: 0x222222,
    SPRING_FLOOR: 0xFFA500, 
    SPRING_SIDE: 0xCD8500,  
    PIYO_BODY: 0xFFD700, 
    PIYO_BEAK: 0xFFA500, 
    PIYO_EYE: 0x000000,  
    BLOCK: 0x6A5ACD, 
    TIRE: 0x333333,
    TIRE_WHEEL: 0xCCCCCC
};

let baseSpeedVal = 0.25;
if (IS_IOS) {
    baseSpeedVal = 0.32;
    if (IS_STANDALONE) {
        baseSpeedVal = 0.45;
    }
}

const GAME_CONFIG = {
    LANE_COUNT: 4,
    LANE_WIDTH: 2.5,
    TILE_SIZE: 3,
    BASE_SPEED: baseSpeedVal, // „Åì„Çå„ÇíÂãïÁöÑ„Å´Â§âÊõ¥„Åô„Çã
    TIRE_SPEED_RATIO: 1.3,
    SLOW_SPEED_RATIO: 0.8,
    GRAVITY: 0.025,           
    FLOAT_GRAVITY: 0.008, 
    JUMP_FORCE: 0.45,
    LONG_JUMP_FORCE: 0.35, 
    TIRE_DURATION_MS: 20000,
    SLOW_DURATION_MS: 5000
};

let gameState = {
    isPlaying: false,
    score: 0,
    lives: 3,
    hp: 100,
    frameCount: 0,
    slowEndTime: 0,
    tireEndTime: 0
};

let currentSpeed = GAME_CONFIG.BASE_SPEED;

let scene, camera, renderer;
let piyo, world, objectManager, inputManager, particleSystem;
let textureMap = {}; 

let matGroundA, matGroundB, matSpring;

// --- 4. Setup ---

function init() {
    const emojis = {
        'cloud': "‚òÅÔ∏è",
        'cake': "üç∞",
        'onigiri': "üçô",
        'chili': "üå∂Ô∏è",
        'fire': "üî•",
        'ghost': "üëª",
        'impact': "üí•",
        'sparkle': "‚ú®"
    };
    for (const [key, emoji] of Object.entries(emojis)) {
        textureMap[key] = createEmojiTexture(emoji, 64);
    }

    matGroundA = new THREE.MeshLambertMaterial({ color: COLORS.GROUND_A });
    matGroundB = new THREE.MeshLambertMaterial({ color: COLORS.GROUND_B });
    
    const matSpringSide = new THREE.MeshLambertMaterial({ color: COLORS.SPRING_SIDE });
    const matSpringTop = new THREE.MeshLambertMaterial({ color: COLORS.SPRING_FLOOR });
    matSpring = [matSpringSide, matSpringSide, matSpringTop, matSpringSide, matSpringSide, matSpringSide];

    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.SKY);

    camera = new THREE.PerspectiveCamera(50, 1.0, 0.1, 80);
    camera.position.set(2, 8, 14); 
    camera.lookAt(2, 3, 0);

    const container = document.getElementById('game-container');
    renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" }); 
    renderer.shadowMap.enabled = false;
    container.appendChild(renderer.domElement);
    
    resizeRenderer();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 15, 10);
    scene.add(dirLight);

    world = new World();
    piyo = new Piyo();
    objectManager = new ObjectManager();
    particleSystem = new ParticleSystem();
    inputManager = new InputManager();

    window.addEventListener('resize', resizeRenderer, false);
    
    document.getElementById('start-sound-on').addEventListener('click', () => startGame(true));
    document.getElementById('start-sound-off').addEventListener('click', () => startGame(false));
    document.getElementById('retry-btn').addEventListener('click', () => {
        document.getElementById('start-buttons').classList.remove('hidden');
        document.getElementById('speed-selector').classList.remove('hidden'); // „Çπ„Éî„Éº„ÉâÈÅ∏Êäû„ÇÇÂÜçË°®Á§∫
        document.getElementById('retry-btn').classList.add('hidden');
        document.getElementById('result-area').classList.add('hidden');
        document.getElementById('ranking-board').classList.add('hidden');
        document.getElementById('title-text').innerText = "„Å¥„Çà„É©„É≥„Éä„Éº";
        document.getElementById('instructions').classList.remove('hidden');
    });

    const btns = document.querySelectorAll('button');
    btns.forEach(b => {
        b.addEventListener('touchstart', (e) => e.stopPropagation(), {passive: true});
    });

    // „Çπ„Éî„Éº„ÉâÈÅ∏Êäû„ÅÆ„É©„Ç∏„Ç™„Éú„Çø„É≥„ÅÆ„Çø„ÉÉ„Éó‰ºùÊí≠Èò≤Ê≠¢
    const radios = document.querySelectorAll('input[name="speed"]');
    radios.forEach(r => {
        r.parentElement.addEventListener('touchstart', (e) => e.stopPropagation(), {passive: true});
    });

    animate();
}

function resizeRenderer() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    let gameW, gameH;

    if (h > w) {
        gameW = h;
        gameH = w;
    } else {
        gameW = w;
        gameH = h;
    }

    camera.aspect = gameW / gameH;
    camera.updateProjectionMatrix();
    
    const dpr = window.devicePixelRatio || 1;
    if (IS_IOS) {
        renderer.setPixelRatio(Math.min(dpr, 1.0));
    } else {
        renderer.setPixelRatio(Math.min(dpr, 1.5));
    }
    renderer.setSize(gameW, gameH, false);
}

function createEmojiTexture(emoji, size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, size, size);
    ctx.font = `${size * 0.8}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, size / 2, size / 2 + size * 0.1);
    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter; 
    return tex;
}

// --- 5. Particle System ---
class ParticleSystem {
    constructor() {
        this.particles = [];
        this.pool = []; 
        this.meshGroup = new THREE.Group();
        scene.add(this.meshGroup);
        this.planeGeo = new THREE.PlaneGeometry(2.0, 2.0); 
        this.matCache = {}; 
    }

    getMaterial(textureName) {
        if (!this.matCache[textureName]) {
            this.matCache[textureName] = new THREE.MeshBasicMaterial({ 
                map: textureMap[textureName], 
                transparent: true, 
                side: THREE.DoubleSide,
                depthWrite: false
            });
        }
        return this.matCache[textureName];
    }

    emit(position, type) {
        let p = this.pool.pop();
        if (!p) {
            const mesh = new THREE.Mesh(this.planeGeo, this.getMaterial(type));
            this.meshGroup.add(mesh);
            p = { mesh: mesh, life: 0, active: false };
        }

        p.mesh.material = this.getMaterial(type);
        p.mesh.position.copy(position);
        p.mesh.position.y += 1.0; 
        p.mesh.visible = true;
        p.mesh.scale.setScalar(0.5);
        p.mesh.rotation.z = (Math.random() - 0.5); 
        p.mesh.lookAt(camera.position);

        p.life = 1.0;
        p.active = true;
        this.particles.push(p);
    }

    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            if (!p.active) continue;

            p.life -= 0.08; 
            const scale = 0.5 + (1.0 - p.life) * 1.5; 
            p.mesh.scale.setScalar(scale);
            p.mesh.material.opacity = p.life;
            p.mesh.position.y += 0.05; 
            
            if (p.life <= 0) {
                p.active = false;
                p.mesh.visible = false;
                this.pool.push(p);
                this.particles.splice(i, 1);
            }
        }
    }
    
    reset() {
        this.particles.forEach(p => {
            p.active = false;
            p.mesh.visible = false;
            this.pool.push(p);
        });
        this.particles = [];
    }
}

// --- 6. Classes ---

class Piyo {
    constructor() {
        this.mesh = new THREE.Group();
        
        const bodyGeo = new THREE.SphereGeometry(0.6, 8, 6); 
        const bodyMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_BODY });
        this.body = new THREE.Mesh(bodyGeo, bodyMat);
        this.mesh.add(this.body);

        const headGeo = new THREE.SphereGeometry(0.5, 8, 6);
        this.head = new THREE.Mesh(headGeo, bodyMat);
        this.head.position.set(0.4, 0.7, 0); 
        this.mesh.add(this.head);

        const beakGeo = new THREE.ConeGeometry(0.15, 0.4, 4);
        const beakMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_BEAK });
        this.beak = new THREE.Mesh(beakGeo, beakMat);
        this.beak.rotation.z = -Math.PI / 2; 
        this.beak.position.set(0.9, 0.7, 0); 
        this.mesh.add(this.beak);

        const eyeGeo = new THREE.SphereGeometry(0.06, 4, 4);
        const eyeMat = new THREE.MeshBasicMaterial({ color: COLORS.PIYO_EYE });
        this.eyeL = new THREE.Mesh(eyeGeo, eyeMat);
        this.eyeL.position.set(0.75, 0.85, 0.25); 
        this.mesh.add(this.eyeL);
        this.eyeR = new THREE.Mesh(eyeGeo, eyeMat);
        this.eyeR.position.set(0.75, 0.85, -0.25); 
        this.mesh.add(this.eyeR);
        
        const wingGeo = new THREE.SphereGeometry(0.4, 6, 4);
        wingGeo.scale(1, 0.5, 0.2); 
        const wingL = new THREE.Mesh(wingGeo, bodyMat);
        wingL.position.set(0, 0.2, 0.5);
        wingL.rotation.y = -0.3;
        this.mesh.add(wingL);
        const wingR = new THREE.Mesh(wingGeo, bodyMat);
        wingR.position.set(0, 0.2, -0.5);
        wingR.rotation.y = 0.3;
        this.mesh.add(wingR);

        const shadowGeo = new THREE.CircleGeometry(0.5, 8);
        const shadowMat = new THREE.MeshBasicMaterial({ 
            color: 0x000000, 
            transparent: true, 
            opacity: 0.3 
        });
        this.fakeShadow = new THREE.Mesh(shadowGeo, shadowMat);
        this.fakeShadow.rotation.x = -Math.PI / 2;
        this.fakeShadow.position.y = -0.55; 
        this.mesh.add(this.fakeShadow);

        this.tireGroup = new THREE.Group();
        this.tireGroup.visible = false;
        const tireGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 8); 
        tireGeo.rotateX(Math.PI / 2);
        const tireMat = new THREE.MeshLambertMaterial({ color: COLORS.TIRE });
        
        const tireL = new THREE.Mesh(tireGeo, tireMat);
        tireL.position.set(0, 0, 0.8);
        const tireR = new THREE.Mesh(tireGeo, tireMat);
        tireR.position.set(0, 0, -0.8);
        
        this.tireGroup.add(tireL);
        this.tireGroup.add(tireR);
        this.mesh.add(this.tireGroup);

        scene.add(this.mesh);
        this.reset();
    }

    getZFromLane(lane) {
        const centerOffset = (GAME_CONFIG.LANE_COUNT - 1) * GAME_CONFIG.LANE_WIDTH / 2;
        return (lane * GAME_CONFIG.LANE_WIDTH) - centerOffset;
    }

    reset() {
        this.lane = 1;
        this.mesh.position.set(-4, 1, this.getZFromLane(this.lane));
        this.yVelocity = 0;
        this.isJumping = false;
        this.isFloating = false;
        this.invincibleTimer = 0;
        this.mesh.visible = true;
        this.onHole = false;
        this.falling = false;
        this.respawning = false;
        this.mesh.rotation.set(0,0,0);
        this.tireGroup.visible = false;
        
        this.head.material.color.setHex(COLORS.PIYO_BODY);
        this.body.material.color.setHex(COLORS.PIYO_BODY);
    }

    moveLane(direction) {
        if (!gameState.isPlaying || this.falling || this.respawning) return;
        this.lane += direction;
        if (this.lane < 0) this.lane = 0;
        if (this.lane >= GAME_CONFIG.LANE_COUNT) this.lane = GAME_CONFIG.LANE_COUNT - 1;
    }

    jump(forceType = 'normal') {
        if (!gameState.isPlaying || this.falling || this.respawning) return;
        
        if (!this.isJumping || forceType === 'long') {
            soundManager.playTone('jump');
            this.isJumping = true;
            if (forceType === 'long') {
                this.yVelocity = GAME_CONFIG.LONG_JUMP_FORCE;
                this.isFloating = true; 
            } else {
                this.yVelocity = GAME_CONFIG.JUMP_FORCE;
                this.isFloating = false;
            }
        }
    }

    activateTire() {
        gameState.tireEndTime = Date.now() + GAME_CONFIG.TIRE_DURATION_MS;
        this.tireGroup.visible = true;
        soundManager.playTone('powerup');
        updateOverlayEffect('blue');
    }

    damage(amount) {
        if (this.invincibleTimer > 0 || this.falling || this.respawning) return; 
        
        gameState.hp -= amount;
        updateUI();
        flashScreen();
        soundManager.playTone('damage');
        
        particleSystem.emit(this.mesh.position, 'impact'); 

        this.setInvincible(60); 

        if (gameState.hp <= 0) {
            gameState.lives--;
            gameState.hp = 100;
            updateUI();
            showBubbu(); 

            if (gameState.lives <= 0) {
                this.die();
            } else {
                this.respawning = true;
                this.mesh.visible = false; 
                if (gameState.tireEndTime > 0) {
                      gameState.tireEndTime = 0;
                      this.tireGroup.visible = false;
                      updateOverlayEffect(null);
                }
                setTimeout(() => {
                    if(!gameState.isPlaying) return;
                    this.respawn();
                }, 2000); 
            }
        }
    }

    heal(amount) {
        gameState.hp = Math.min(100, gameState.hp + amount);
        updateUI();
        this.head.material.emissive.setHex(0x004400);
        setTimeout(() => { this.head.material.emissive.setHex(0x000000); }, 200);
    }

    setInvincible(time) {
        this.invincibleTimer = time;
    }

    handleFall() {
        if (!this.falling && !this.respawning) {
            this.falling = true;
            gameState.lives--;
            updateUI();
            flashScreen(); 
            showBubbu(); 
            soundManager.playTone('damage');

            if (gameState.lives > 0) {
                this.respawning = true;
                if (gameState.tireEndTime > 0) {
                      gameState.tireEndTime = 0;
                      this.tireGroup.visible = false;
                      updateOverlayEffect(null);
                }
                setTimeout(() => {
                    if(!gameState.isPlaying) return;
                    this.respawn();
                }, 1500);
            } else {
                setTimeout(() => {
                    this.die();
                }, 1000);
            }
        }
    }

    respawn() {
        this.falling = false; 
        this.mesh.position.y = 12; 
        this.mesh.position.z = this.getZFromLane(this.lane); 
        this.mesh.rotation.set(0,0,0); 
        this.mesh.visible = true; 
        this.yVelocity = 0; 
        this.isJumping = true; 
        this.onHole = false;    
        this.isFloating = false;
        gameState.hp = 100;
        gameState.slowEndTime = 0;
        gameState.tireEndTime = 0;
        this.tireGroup.visible = false;
        updateOverlayEffect(null);

        updateUI();
        this.setInvincible(180);
        
        setTimeout(() => { this.respawning = false; }, 500);
    }

    die() {
        gameState.lives = 0;
        gameState.hp = 0;
        updateUI();
        gameOver();
    }

    update() {
        this.targetZ = this.getZFromLane(this.lane);
        const isSlow = (gameState.slowEndTime > Date.now());
        const lerpFactor = isSlow ? 0.1 : 0.25;
        this.mesh.position.z += (this.targetZ - this.mesh.position.z) * lerpFactor;

        const isTire = (gameState.tireEndTime > Date.now());
        if (isTire) {
            this.tireGroup.children.forEach(t => t.rotation.x -= 0.5);
            this.mesh.position.x = -4 + (Math.random()-0.5)*0.1;
        } else {
            this.mesh.position.x = -4;
        }

        this.fakeShadow.position.x = 0; 
        this.fakeShadow.position.z = 0;
        const dist = Math.abs(this.mesh.position.y - 1);
        const sScale = Math.max(0, 1 - dist * 0.15);
        this.fakeShadow.scale.setScalar(sScale);
        this.fakeShadow.material.opacity = Math.max(0, 0.3 - dist * 0.05);
        if (this.onHole && !this.isJumping) {
            this.fakeShadow.visible = false;
        } else {
            this.fakeShadow.visible = true;
            this.fakeShadow.position.y = -this.mesh.position.y + 0.05; 
        }

        if (this.isJumping) {
            const timeScale = isSlow ? 0.6 : 1.0;
            this.mesh.position.y += this.yVelocity * timeScale;
            const currentGravity = this.isFloating ? GAME_CONFIG.FLOAT_GRAVITY : GAME_CONFIG.GRAVITY;
            this.yVelocity -= currentGravity * timeScale;

            if (this.isFloating) {
                this.mesh.rotation.z -= 0.15 * timeScale;
            } else {
                this.mesh.rotation.z += (0 - this.mesh.rotation.z) * 0.1;
            }

            if (this.mesh.position.y <= 1 && !this.onHole && !this.falling) {
                this.mesh.position.y = 1;
                this.isJumping = false;
                this.isFloating = false;
                this.yVelocity = 0;
                this.mesh.rotation.z = 0; 
            }
        } else {
            this.bounceOffset = (this.bounceOffset || 0) + (isSlow ? 0.1 : 0.3);
            
            if (!this.onHole && this.mesh.position.y > -1.0) {
                if (isTire) {
                      this.mesh.position.y = 1;
                } else {
                    this.mesh.position.y = 1 + Math.abs(Math.sin(this.bounceOffset)) * 0.15;
                    this.mesh.rotation.z = Math.sin(this.bounceOffset) * 0.05; 
                }
            } else {
                this.mesh.position.y -= 0.3;
                this.mesh.rotation.z += 0.2; 
                if (this.mesh.position.y < -5 && !this.falling) {
                    this.handleFall();
                }
            }
        }

        if (this.invincibleTimer > 0) {
            this.invincibleTimer--;
            if (!this.respawning) {
                this.mesh.visible = Math.floor(this.invincibleTimer / 5) % 2 === 0;
                if (this.invincibleTimer === 0) {
                    this.mesh.visible = true;
                }
            }
        }
    }
}

class World {
    constructor() {
        this.tiles = [];
        this.tileGroup = new THREE.Group();
        scene.add(this.tileGroup);
        this.sceneryGroup = new THREE.Group();
        scene.add(this.sceneryGroup);
        this.setupScenery();
        this.cols = 20; 
        this.holeReservations = [false, false, false, false]; 

        for (let x = 0; x < this.cols; x++) {
            for (let z = 0; z < GAME_CONFIG.LANE_COUNT; z++) {
                this.createTile(x, z);
            }
        }
    }

    setupScenery() {
        for(let i=0; i<6; i++) { 
            const size = 5 + Math.random() * 5;
            const geo = new THREE.PlaneGeometry(size, size);
            const mat = new THREE.MeshBasicMaterial({ 
                map: textureMap['cloud'], 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.set(
                Math.random() * 80 - 20, 
                5 + Math.random() * 10,   
                -10 - Math.random() * 10  
            );
            mesh.userData = { speedRate: 0.05 + Math.random() * 0.1 };
            this.sceneryGroup.add(mesh);
        }
    }

    createTile(gridX, laneIndex) {
        const size = GAME_CONFIG.TILE_SIZE;
        const geo = new THREE.BoxGeometry(size, 1, GAME_CONFIG.LANE_WIDTH - 0.1);
        const isEven = (gridX + laneIndex) % 2 === 0;
        const mat = isEven ? matGroundA : matGroundB;
        const mesh = new THREE.Mesh(geo, mat);

        const z = (laneIndex * GAME_CONFIG.LANE_WIDTH) - ((GAME_CONFIG.LANE_COUNT - 1) * GAME_CONFIG.LANE_WIDTH / 2);
        const xStart = -10; 
        const x = xStart + gridX * size;
        mesh.position.set(x, -0.5, z);

        const tileData = {
            mesh: mesh,
            gridX: gridX,
            lane: laneIndex,
            type: 'normal'
        };
        mesh.userData = tileData;
        this.tiles.push(tileData);
        this.tileGroup.add(mesh);
    }

    reset() {
        this.holeReservations = [false, false, false, false];
        this.tiles.forEach(t => {
            const size = GAME_CONFIG.TILE_SIZE;
            const xStart = -10;
            t.mesh.position.x = xStart + t.gridX * size;
            this.resetTileType(t);
        });
    }

    resetTileType(tile) {
        tile.type = 'normal';
        tile.mesh.visible = true;
        tile.mesh.rotation.set(0, 0, 0);
        tile.mesh.position.y = -0.5;
        const isEven = (tile.gridX + tile.lane) % 2 === 0;
        tile.mesh.material = isEven ? matGroundA : matGroundB;
    }

    update() {
        const speed = currentSpeed;
        const size = GAME_CONFIG.TILE_SIZE;
        const limitX = -20; 
        
        this.sceneryGroup.children.forEach(cloud => {
            cloud.position.x -= speed * cloud.userData.speedRate;
            if (cloud.position.x < -30) cloud.position.x = 60; 
        });

        this.tiles.forEach(tile => {
            tile.mesh.position.x -= speed;
            if (tile.mesh.position.x < limitX) {
                tile.mesh.position.x += (this.cols * size);
                this.resetTileType(tile);
                objectManager.spawnObjectOnTile(tile);
            }
        });
    }

    getTileAt(x, z) {
        return this.tiles.find(t => 
            Math.abs(t.mesh.position.x - x) < GAME_CONFIG.TILE_SIZE / 2 &&
            Math.abs(t.mesh.position.z - z) < 0.5
        );
    }
}

class ObjectManager {
    constructor() {
        this.objects = [];
        this.pool = [];
        this.objGroup = new THREE.Group();
        scene.add(this.objGroup);
    }

    reset() {
        this.objects.forEach(o => {
            o.mesh.visible = false;
            this.pool.push(o);
        });
        this.objects = [];
    }

    createBoardMesh(textureName, scale = 1.0) {
        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(2 * scale, 2 * scale),
            new THREE.MeshBasicMaterial({ 
                map: textureMap[textureName], 
                transparent: true, 
                alphaTest: 0.5, 
                side: THREE.DoubleSide
            })
        );
        return mesh;
    }

    createMesh(type) {
        let mesh;
        if (type === 'fire') { 
            mesh = this.createBoardMesh('fire', 1.0);
        } else if (type === 'cake') {
            mesh = this.createBoardMesh('cake', 0.8);
        } else if (type === 'onigiri') {
            mesh = this.createBoardMesh('onigiri', 0.8);
        } else if (type === 'chili') {
            mesh = this.createBoardMesh('chili', 0.8);
        } else if (type === 'tire') {
            const g = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8); 
            g.rotateX(Math.PI/2);
            mesh = new THREE.Mesh(g, new THREE.MeshLambertMaterial({color:0x333333}));
            const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.31,8), new THREE.MeshLambertMaterial({color:0xcccccc}));
            wheel.rotateX(Math.PI/2);
            mesh.add(wheel);
        } else if (type === 'moving_block') {
            const group = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(1.8, 1.8, 2.4);
            const matBase = new THREE.MeshLambertMaterial({ color: COLORS.BLOCK });
            const matDark = new THREE.MeshLambertMaterial({ color: 0x483D8B });
            const block = new THREE.Mesh(geometry, [matBase, matBase, matDark, matDark, matBase, matBase]);
            group.add(block);

            const shadowGeo = new THREE.PlaneGeometry(1.8, 2.4);
            const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.rotation.x = -Math.PI / 2;
            shadow.name = "blockShadow";
            group.add(shadow);

            mesh = group;
        } else if (type === 'ghost_sign') {
            const group = new THREE.Group();
            const stickGeo = new THREE.CylinderGeometry(0.1, 0.1, 10, 4);
            const stickMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); 
            const stick = new THREE.Mesh(stickGeo, stickMat);
            stick.position.y = 4; 
            stick.position.z = -0.1; 
            group.add(stick);

            const board = this.createBoardMesh('ghost', 1.2);
            board.position.y = 9; 
            board.rotation.y = 0; 
            group.add(board);

            mesh = group;
        }
        
        if(mesh) {
            this.objGroup.add(mesh);
        }
        return mesh;
    }

    spawnObjectOnTile(tile) {
        if (this.objects.filter(o => o.active).length >= 8) return;

        if (world.holeReservations[tile.lane]) {
            tile.type = 'hole';
            tile.mesh.visible = false;
            world.holeReservations[tile.lane] = false; 
            return;
        }

        const rand = Math.random();

        if (rand < 0.02) {
            tile.type = 'hole';
            tile.mesh.visible = false;
            if (Math.random() < 0.5) {
                world.holeReservations[tile.lane] = true;
            }
            return; 
        }
        
        if (rand < 0.05) {
            tile.type = 'spring';
            tile.mesh.material = matSpring;
            tile.mesh.rotation.z = 0.3; 
            tile.mesh.position.y = 0; 
            return;
        }

        if (rand < 0.20) { 
            let type = null;
            const subRand = Math.random();
            
            if (subRand < 0.25) type = 'fire';
            else if (subRand < 0.35) type = 'moving_block';
            else if (subRand < 0.50) type = 'ghost_sign'; 
            else if (subRand < 0.70) type = 'cake'; 
            else if (subRand < 0.85) type = 'onigiri';
            else if (subRand < 0.92) type = 'chili';
            else type = 'tire'; 

            if (type === 'onigiri' && gameState.hp >= 95) type = 'cake';

            if (type === 'fire' && Math.random() < 0.3 && tile.lane < GAME_CONFIG.LANE_COUNT - 1) {
                if (this.objects.filter(o => o.active).length >= 7) { 
                    this.spawnSingle(type, tile.mesh.position.x, tile.mesh.position.z);
                    return;
                }
                this.spawnSingle(type, tile.mesh.position.x, tile.mesh.position.z);
                const z2 = tile.mesh.position.z + GAME_CONFIG.LANE_WIDTH;
                this.spawnSingle(type, tile.mesh.position.x, z2);
                return;
            }

            this.spawnSingle(type, tile.mesh.position.x, tile.mesh.position.z);
        }
    }

    spawnSingle(type, x, z) {
        let objData = this.pool.find(o => !o.active && o.type === type);
        if (!objData) {
            objData = { mesh: this.createMesh(type), type: type, active: false };
            this.objects.push(objData);
        } else {
            this.pool = this.pool.filter(o => o !== objData);
            this.objects.push(objData);
        }

        objData.active = true;
        objData.mesh.visible = true;
        objData.mesh.position.set(x, 0.5, z);
        objData.mesh.rotation.set(0,0,0);
        
        if (['cake', 'onigiri', 'chili'].includes(type)) {
            objData.mesh.position.y = 1.0;
        } else if (type === 'tire') {
            objData.mesh.position.y = 0.8;
            objData.mesh.rotation.x = Math.PI/2;
        } else if (type === 'fire') {
            objData.mesh.position.y = 0.8; 
        } else if (type === 'moving_block') {
            const tiers = [1.2, 3.0, 5.0];
            const y = tiers[Math.floor(Math.random() * tiers.length)];
            objData.mesh.position.y = y;
            const laneOffset = (Math.random() - 0.5) * (GAME_CONFIG.LANE_WIDTH * 0.8);
            objData.mesh.position.z += laneOffset;

            const shadow = objData.mesh.children.find(c => c.name === "blockShadow");
            if (shadow) {
                shadow.position.y = -y + 0.05; 
            }

        } else if (type === 'ghost_sign') {
            objData.mesh.position.y = -12;
        }
    }

    update() {
        const speed = currentSpeed;
        
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            obj.mesh.position.x -= speed;

            if (['cake', 'onigiri', 'chili', 'tire'].includes(obj.type)) {
                 obj.mesh.position.y = 1.0 + Math.sin(gameState.frameCount * 0.1 + obj.mesh.id) * 0.1;
            } 
            else if (obj.type === 'fire') {
                obj.mesh.lookAt(camera.position);
            }
            else if (obj.type === 'ghost_sign') {
                const t = gameState.frameCount * 0.03 + obj.mesh.id;
                const yOffset = (Math.sin(t) + 1) / 2 * 8; 
                obj.mesh.position.y = -8 + yOffset;
            }

            if (obj.mesh.position.x < -20) this.deactivate(obj, i);
        }
    }

    deactivate(obj, index) {
        obj.active = false;
        obj.mesh.visible = false;
        this.objects.splice(index, 1);
        this.pool.push(obj);
    }

    checkCollision(player) {
        const pPos = player.mesh.position;
        
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            const oPos = obj.mesh.position;
            
            const dx = Math.abs(pPos.x - oPos.x);
            let hitX = 1.0;
            if (obj.type === 'moving_block') hitX = 1.6;

            if (dx > hitX) continue;

            const dz = Math.abs(pPos.z - oPos.z);
            let hitZ = 1.2;
            if (obj.type === 'moving_block') hitZ = 1.8; 
            if (obj.type === 'ghost_sign') hitZ = 0.8; 

            if (dz > hitZ) continue; 

            const dy = Math.abs(pPos.y - oPos.y);
            let hitY = 1.2; 
            if (obj.type === 'fire') hitY = 1.0; 
            if (['cake', 'onigiri', 'chili', 'tire'].includes(obj.type)) hitY = 1.5;
            if (obj.type === 'moving_block') hitY = 1.8;
            
            if (obj.type === 'ghost_sign') {
                const topY = oPos.y + 10; 
                const bottomY = oPos.y - 1; 
                if (pPos.y < topY && pPos.y > bottomY) {
                    this.resolveCollision(player, obj, i);
                }
                continue;
            }

            if (dy > hitY) continue; 

            this.resolveCollision(player, obj, i);
        }
    }

    resolveCollision(player, obj, index) {
        const type = obj.type;

        if (['cake', 'onigiri', 'tire'].includes(type)) {
            particleSystem.emit(obj.mesh.position, 'sparkle');
        }

        if (type === 'cake') {
            soundManager.playTone('coin');
            gameState.score += 300; 
            updateUI();
            this.deactivate(obj, index);
        } else if (type === 'onigiri') {
            soundManager.playTone('coin');
            player.heal(30); 
            this.deactivate(obj, index);
        } else if (type === 'tire') {
            player.activateTire();
            this.deactivate(obj, index);
        } else if (type === 'chili') {
            soundManager.playTone('slow');
            gameState.slowEndTime = Date.now() + GAME_CONFIG.SLOW_DURATION_MS;
            updateOverlayEffect('red');
            particleSystem.emit(obj.mesh.position, 'impact');
            this.deactivate(obj, index);
        } 
        else if (type === 'fire' || type === 'moving_block' || type === 'ghost_sign') {
            if (player.invincibleTimer > 0) return;
            
            particleSystem.emit(obj.mesh.position, 'impact');
            if(type === 'moving_block') player.damage(35);
            else player.damage(25);
        }
    }
}

class InputManager {
    constructor() {
        this.startX = 0;
        this.startY = 0;
        this.isTouching = false;
        
        // Á∏¶ÊåÅ„Å°Âà§ÂÆö„Éï„É©„Ç∞
        this.isPortrait = false;

        document.addEventListener('touchstart', this.onTouchStart.bind(this), {passive: false});
        document.addEventListener('touchmove', this.onTouchMove.bind(this), {passive: false});
        document.addEventListener('touchend', this.onTouchEnd.bind(this), {passive: false});
        document.addEventListener('mousedown', this.onMouseDown.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));
    }

    getTransformedPoint(clientX, clientY) {
        if (window.innerHeight > window.innerWidth) {
            this.isPortrait = true;
            return { x: clientY, y: clientX }; 
        } else {
            this.isPortrait = false;
            return { x: clientX, y: clientY };
        }
    }

    onTouchStart(e) {
        const p = this.getTransformedPoint(e.touches[0].clientX, e.touches[0].clientY);
        this.startX = p.x;
        this.startY = p.y;
        this.isTouching = true;
    }

    onTouchMove(e) {
        if (!this.isTouching) return;
        if (gameState.isPlaying) e.preventDefault(); 
    }

    onTouchEnd(e) {
        if (!this.isTouching) return;
        const p = this.getTransformedPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        this.handleGesture(this.startX, this.startY, p.x, p.y);
        this.isTouching = false;
    }

    onMouseDown(e) {
        const p = this.getTransformedPoint(e.clientX, e.clientY);
        this.startX = p.x;
        this.startY = p.y;
        this.isTouching = true;
    }
    onMouseUp(e) {
        if (!this.isTouching) return;
        const p = this.getTransformedPoint(e.clientX, e.clientY);
        this.handleGesture(this.startX, this.startY, p.x, p.y);
        this.isTouching = false;
    }

    handleGesture(x1, y1, x2, y2) {
        if (!gameState.isPlaying) return;

        const dx = x2 - x1;
        const dy = y2 - y1; 
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 30) {
            piyo.jump('normal');
        } else {
            // „Çπ„ÉØ„Ç§„ÉóÂà§ÂÆö
            // dy„ÅØ„ÄÅÁ∏¶ÊåÅ„Å°Â§âÊèõÂæå„ÄÅÁîªÈù¢„ÅÆ„ÄåÁü≠Ëæ∫ÔºàÊú¨Êù•„ÅÆÊ®™Ôºâ„ÄçÊñπÂêë„ÅÆÂãï„Åç
            if (Math.abs(dy) > Math.abs(dx)) {
                if (this.isPortrait) {
                    // ‰øÆÊ≠£ÔºöÁ∏¶ÊåÅ„Å°ÊôÇ„ÅØÂà§ÂÆö„ÇíÈÄÜËª¢„Åï„Åõ„Çã
                    // ÁîªÈù¢„ÅÆÂè≥ÊñπÂêë„Å∏„Çπ„ÉØ„Ç§„ÉóÔºàdy > 0Ôºâ‚Üí Â∑¶„É¨„Éº„É≥„Å∏
                    // ÁîªÈù¢„ÅÆÂ∑¶ÊñπÂêë„Å∏„Çπ„ÉØ„Ç§„ÉóÔºàdy < 0Ôºâ‚Üí Âè≥„É¨„Éº„É≥„Å∏
                    if (dy < 0) piyo.moveLane(1); 
                    else piyo.moveLane(-1); 
                } else {
                    // Ê®™ÊåÅ„Å°ÊôÇ„ÅØÈÄöÂ∏∏„ÅÆÂà§ÂÆö
                    if (dy < 0) piyo.moveLane(-1); 
                    else piyo.moveLane(1); 
                }
            }
        }
    }
}

// --- 7. Game Loop ---

function startGame(soundEnabled) {
    soundManager.init(soundEnabled);
    
    // „Çπ„Éî„Éº„ÉâË®≠ÂÆö„ÅÆÂèñÂæó
    const speedRadio = document.querySelector('input[name="speed"]:checked');
    const speedMode = speedRadio ? speedRadio.value : 'low';
    
    // „Çπ„Éî„Éº„Éâ„ÅÆË®≠ÂÆö
    // baseSpeedVal„ÅØÁí∞Â¢ÉÂà§ÂÆöÔºàiOSÁ≠âÔºâ„Å´„Çà„ÇãÂü∫Ê∫ñÂÄ§ÔºàHighÁõ∏ÂΩìÔºâ
    // Low„ÅÆÂ†¥Âêà„ÅØ0.8ÂÄçÔºàÂîêËæõÂ≠ê„Å®Âêå„ÅòÂÄçÁéáÔºâ„Å´„Åô„Çã
    if (speedMode === 'low') {
        GAME_CONFIG.BASE_SPEED = baseSpeedVal * 0.8;
    } else {
        GAME_CONFIG.BASE_SPEED = baseSpeedVal;
    }

    document.getElementById('start-buttons').classList.add('hidden');
    document.getElementById('speed-selector').classList.add('hidden'); // „Çπ„Éî„Éº„ÉâÈÅ∏Êäû„ÇíÈö†„Åô
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('result-area').classList.add('hidden');
    document.getElementById('ranking-board').classList.add('hidden');
    document.getElementById('instructions').classList.add('hidden');
    document.getElementById('title-text').classList.add('hidden');

    gameState.isPlaying = true;
    gameState.score = 0;
    gameState.lives = 3;
    gameState.hp = 100;
    gameState.frameCount = 0;
    gameState.slowEndTime = 0;
    gameState.tireEndTime = 0;
    
    // ÁèæÂú®„ÅÆÈÄüÂ∫¶„ÇíÂàùÊúüÂÄ§„Å´„Çª„ÉÉ„Éà
    currentSpeed = GAME_CONFIG.BASE_SPEED;

    piyo.reset();
    world.reset();
    objectManager.reset();
    particleSystem.reset();
    
    updateUI();
}

function gameOver() {
    gameState.isPlaying = false;
    document.getElementById('overlay').classList.remove('hidden');
    document.getElementById('title-text').classList.remove('hidden');
    document.getElementById('title-text').innerText = "GAME OVER";
    
    const resultArea = document.getElementById('result-area');
    resultArea.classList.remove('hidden');
    document.getElementById('final-score').innerText = Math.floor(gameState.score);
    
    // „É©„É≥„Ç≠„É≥„Ç∞Âá¶ÁêÜ
    const rankData = rankingManager.save(gameState.score);
    renderRanking(rankData);

    document.getElementById('ranking-board').classList.remove('hidden');
    
    document.getElementById('retry-btn').classList.remove('hidden');
    document.getElementById('retry-btn').innerText = "„ÇÇ„ÅÜ‰∏ÄÂ∫¶";
    
    updateOverlayEffect(null);
}

function renderRanking(rankData) {
    const listEl = document.getElementById('ranking-list');
    listEl.innerHTML = '';

    rankData.list.forEach((item, index) => {
        const li = document.createElement('li');
        li.className = 'rank-item';
        
        // ‰ªäÂõû„ÅÆËá™ÂàÜ„ÅÆ„Çπ„Ç≥„Ç¢„Çí„Éè„Ç§„É©„Ç§„Éà
        if (item.id === rankData.currentId) {
            li.classList.add('current-score');
        }

        const rankSpan = document.createElement('span');
        rankSpan.className = 'rank-rank';
        rankSpan.textContent = (index + 1) + '‰Ωç';

        const scoreSpan = document.createElement('span');
        scoreSpan.className = 'rank-score';
        scoreSpan.textContent = item.score.toLocaleString();

        const dateSpan = document.createElement('span');
        dateSpan.className = 'rank-date';
        dateSpan.textContent = item.date;

        li.appendChild(rankSpan);
        li.appendChild(scoreSpan);
        li.appendChild(dateSpan);
        listEl.appendChild(li);
    });

    // „É™„Çπ„Éà„ÅÆ„Éà„ÉÉ„Éó„Å∏„Çπ„ÇØ„É≠„Éº„É´
    setTimeout(() => {
        const myItem = listEl.querySelector('.current-score');
        if (myItem) {
            myItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
}

function updateUI() {
    let heartStr = "";
    for(let i=0; i<gameState.lives; i++) heartStr += "‚ù§Ô∏è";
    document.getElementById('lives').innerText = heartStr;
    document.getElementById('hp-bar').style.width = Math.max(0, gameState.hp) + "%";
    document.getElementById('score-board').innerText = Math.floor(gameState.score);
}

function showBubbu() {
    const el = document.getElementById('bubbu-msg');
    el.classList.add('show');
    setTimeout(() => {
        el.classList.remove('show');
    }, 800);
}

function flashScreen() {
    const flash = document.getElementById('damage-flash');
    flash.style.opacity = 0.5;
    setTimeout(() => { flash.style.opacity = 0; }, 100);
}

function updateOverlayEffect(type) {
    const el = document.getElementById('effect-overlay');
    if (type === 'red') {
        el.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; 
        el.style.opacity = 1;
    } else if (type === 'blue') {
        el.style.backgroundColor = 'rgba(0, 0, 255, 0.1)'; 
        el.style.opacity = 1;
    } else {
        el.style.opacity = 0;
    }
}

function checkTileGimmick() {
    if (piyo.isJumping && piyo.mesh.position.y > 2.0) return; 

    const tile = world.getTileAt(piyo.mesh.position.x, piyo.mesh.position.z);
    
    if (tile) {
        piyo.onHole = (tile.type === 'hole');
        if (tile.type === 'spring') piyo.jump('long');
    } else {
        piyo.onHole = false;
    }
}

function animate() {
    requestAnimationFrame(animate);

    if (gameState.isPlaying) {
        gameState.frameCount++;
        
        let targetSpeed = GAME_CONFIG.BASE_SPEED;

        const now = Date.now();
        const isSlow = (gameState.slowEndTime > now);
        const isTire = (gameState.tireEndTime > now);

        if (gameState.slowEndTime > 0 && !isSlow) {
            gameState.slowEndTime = 0; 
            if (!isTire) updateOverlayEffect(null);
        }
        if (gameState.tireEndTime > 0 && !isTire) {
            gameState.tireEndTime = 0; 
            piyo.tireGroup.visible = false;
            if (!isSlow) updateOverlayEffect(null);
        }

        if (isSlow) {
            targetSpeed = GAME_CONFIG.BASE_SPEED * GAME_CONFIG.SLOW_SPEED_RATIO;
        } else if (isTire) {
            targetSpeed = GAME_CONFIG.BASE_SPEED * GAME_CONFIG.TIRE_SPEED_RATIO;
        } 

        currentSpeed += (targetSpeed - currentSpeed) * 0.05;

        world.update();
        objectManager.update();
        piyo.update();
        particleSystem.update();
        checkTileGimmick();
        objectManager.checkCollision(piyo);
        
        if (gameState.frameCount % 10 === 0) updateUI();
    }

    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

init();

</script>
</body>
</html>
