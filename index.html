<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼ï¼ˆã‚¢ã‚¤ãƒ†ãƒ ç››ã‚Šã ãã•ã‚“Verï¼‰</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            background-color: #87CEEB; /* ç©ºã®è‰² */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UIãƒ¬ã‚¤ãƒ¤ãƒ¼ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* ã‚²ãƒ¼ãƒ æ“ä½œã‚’é˜»å®³ã—ãªã„ */
        }

        /* å·¦ä¸Šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
        #status-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #lives {
            font-size: 24px;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
            letter-spacing: 5px; /* ãƒãƒ¼ãƒˆã‚’è¦‹ã‚„ã™ã */
        }

        #hp-container {
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background-color: #ff6b6b;
            transition: width 0.2s;
        }

        /* å³ä¸Šã‚¹ã‚³ã‚¢ */
        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }

        /* ä¸­å¤®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ãƒ»ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰ */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100; /* æœ€å‰é¢ã« */
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 4px 4px 0px #ff6b6b;
            margin: 0 0 20px 0;
        }

        .instructions {
            color: white;
            font-size: 16px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
        }

        .item-list {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 15px;
            text-align: left;
            margin-top: 10px;
            font-size: 14px;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #2E7D32;
            transition: transform 0.1s;
            pointer-events: auto; /* æ˜ç¤ºçš„ã«ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã« */
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }

        /* ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.1s;
        }
        
        /* ã‚¹ãƒ­ãƒ¼åŠ¹æœã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        #slow-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 255, 0.1); /* é’ã£ã½ã„ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ */
            opacity: 0;
            pointer-events: none;
            z-index: 4;
            transition: opacity 0.5s;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    <div id="damage-flash"></div>
    <div id="slow-overlay"></div>

    <div id="ui-layer">
        <div id="status-bar">
            <div id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
            <div id="hp-container">
                <div id="hp-bar"></div>
            </div>
        </div>
        <div id="score-board">0</div>
    </div>

    <div id="overlay">
        <h1 id="title-text">ã´ã‚ˆãƒ©ãƒ³ãƒŠãƒ¼</h1>
        <div class="instructions" id="instructions">
            ğŸ‘† ã‚¿ãƒƒãƒ—ï¼šã‚¸ãƒ£ãƒ³ãƒ—<br>
            â†•ï¸ ä¸Šä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—ï¼šãƒ¬ãƒ¼ãƒ³ç§»å‹•<br>
            <div class="item-list">
                <span>ğŸ°</span><span>ã‚±ãƒ¼ã‚­ï¼šã‚¹ã‚³ã‚¢GETï¼</span>
                <span>ğŸ™</span><span>ãŠã«ãã‚Šï¼šä½“åŠ›å›å¾©</span>
                <span>â­</span><span>ã‚¹ã‚¿ãƒ¼ï¼šç„¡æ•µãƒ¢ãƒ¼ãƒ‰</span>
                <span>ğŸŒ¶</span><span>å”è¾›å­ï¼šã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ€ã‚¦ãƒ³...</span>
                <span>ğŸŒµğŸ‘»</span><span>æ•µï¼šã¶ã¤ã‹ã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼</span>
            </div>
        </div>
        <div class="instructions hidden" id="result-area">
            SCORE: <span id="final-score">0</span>
        </div>
        <button id="start-btn">START</button>
    </div>

<script>
window.onerror = function(message, source, lineno, colno, error) {
    alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n" + message);
};

// --- 1. Constants & Globals ---

const COLORS = {
    SKY: 0x87CEEB,
    GROUND_A: 0x98FB98, 
    GROUND_B: 0x90EE90, 
    HOLE: 0x222222,
    SPRING_FLOOR: 0xFFA500, 
    SPRING_SIDE: 0xCD8500,  
    PIYO_BODY: 0xFFD700, 
    PIYO_BEAK: 0xFFA500, 
    PIYO_EYE: 0x000000,  
    BLOCK: 0x6A5ACD, 
};

const GAME_CONFIG = {
    LANE_COUNT: 4,
    LANE_WIDTH: 2.5,
    TILE_SIZE: 3,
    BASE_SPEED: 0.25,      // åŸºæœ¬é€Ÿåº¦
    SLOW_SPEED: 0.12,      // å”è¾›å­æ™‚ã®é€Ÿåº¦   
    GRAVITY: 0.025,       
    FLOAT_GRAVITY: 0.008, 
    JUMP_FORCE: 0.45,
    LONG_JUMP_FORCE: 0.35, 
    INVINCIBLE_TIME: 180, 
};

let gameState = {
    isPlaying: false,
    score: 0,
    lives: 3,
    hp: 100,
    frameCount: 0,
    slowTimer: 0 // å”è¾›å­åŠ¹æœæ™‚é–“
};

let currentSpeed = GAME_CONFIG.BASE_SPEED;

let scene, camera, renderer;
let piyo, world, objectManager, inputManager;
// æ›¸å‰²ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ä¿æŒç”¨
let textureMap = {}; 

// ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆå†åˆ©ç”¨ã®ãŸã‚ã“ã“ã«ä¿æŒï¼‰
let matGroundA, matGroundB, matSpring;

// --- 2. Setup ---

function init() {
    try {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ä¸€æ‹¬ç”Ÿæˆ
        const emojis = {
            'cloud': "â˜ï¸",
            'cactus': "ğŸŒµ",
            'cake': "ğŸ°",
            'onigiri': "ğŸ™",
            'star': "â­",
            'chili': "ğŸŒ¶",
            'ghost': "ğŸ‘»"
        };
        
        for (const [key, emoji] of Object.entries(emojis)) {
            textureMap[key] = createEmojiTexture(emoji, 128);
        }

        // ãƒãƒ†ãƒªã‚¢ãƒ«åˆæœŸåŒ–
        matGroundA = new THREE.MeshLambertMaterial({ color: COLORS.GROUND_A });
        matGroundB = new THREE.MeshLambertMaterial({ color: COLORS.GROUND_B });
        
        const matSpringSide = new THREE.MeshLambertMaterial({ color: COLORS.SPRING_SIDE });
        const matSpringTop = new THREE.MeshLambertMaterial({ color: COLORS.SPRING_FLOOR });
        matSpring = [
            matSpringSide, matSpringSide, matSpringTop, matSpringSide, matSpringSide, matSpringSide
        ];

        scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.SKY);
        scene.fog = new THREE.Fog(COLORS.SKY, 20, 60);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(2, 10, 15); 
        camera.lookAt(2, 4, 0);

        const container = document.getElementById('game-container');
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 15, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        world = new World();
        piyo = new Piyo();
        objectManager = new ObjectManager();
        inputManager = new InputManager();

        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('start-btn').addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: true});

        animate();
    } catch (e) {
        alert("åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + e);
        console.error(e);
    }
}

function createEmojiTexture(emoji, size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, size, size);
    ctx.font = `${size * 0.8}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, size / 2, size / 2 + size * 0.1);
    return new THREE.CanvasTexture(canvas);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- 3. Classes ---

class Piyo {
    constructor() {
        this.mesh = new THREE.Group();
        
        // --- ãƒ’ãƒ¨ã‚³ãƒ¢ãƒ‡ãƒ« ---
        const bodyGeo = new THREE.SphereGeometry(0.6, 24, 24); 
        const bodyMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_BODY });
        this.body = new THREE.Mesh(bodyGeo, bodyMat);
        this.body.castShadow = true;
        this.mesh.add(this.body);

        const headGeo = new THREE.SphereGeometry(0.5, 24, 24);
        this.head = new THREE.Mesh(headGeo, bodyMat);
        this.head.position.set(0.4, 0.7, 0); 
        this.head.castShadow = true;
        this.mesh.add(this.head);

        const beakGeo = new THREE.ConeGeometry(0.15, 0.4, 8);
        const beakMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_BEAK });
        this.beak = new THREE.Mesh(beakGeo, beakMat);
        this.beak.rotation.z = -Math.PI / 2; 
        this.beak.position.set(0.9, 0.7, 0); 
        this.mesh.add(this.beak);

        const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const eyeMat = new THREE.MeshLambertMaterial({ color: COLORS.PIYO_EYE });
        this.eyeL = new THREE.Mesh(eyeGeo, eyeMat);
        this.eyeL.position.set(0.75, 0.85, 0.25); 
        this.mesh.add(this.eyeL);
        this.eyeR = new THREE.Mesh(eyeGeo, eyeMat);
        this.eyeR.position.set(0.75, 0.85, -0.25); 
        this.mesh.add(this.eyeR);

        const wingGeo = new THREE.SphereGeometry(0.4, 16, 16);
        wingGeo.scale(1, 0.5, 0.2); 
        const wingL = new THREE.Mesh(wingGeo, bodyMat);
        wingL.position.set(0, 0.2, 0.5);
        wingL.rotation.y = -0.3;
        this.mesh.add(wingL);
        const wingR = new THREE.Mesh(wingGeo, bodyMat);
        wingR.position.set(0, 0.2, -0.5);
        wingR.rotation.y = 0.3;
        this.mesh.add(wingR);

        const tailGeo = new THREE.ConeGeometry(0.2, 0.4, 8);
        const tail = new THREE.Mesh(tailGeo, bodyMat);
        tail.rotation.z = Math.PI / 2; 
        tail.rotation.y = 0.3; 
        tail.position.set(-0.6, 0.2, 0);
        this.mesh.add(tail);

        scene.add(this.mesh);
        this.reset();
    }

    getZFromLane(lane) {
        const centerOffset = (GAME_CONFIG.LANE_COUNT - 1) * GAME_CONFIG.LANE_WIDTH / 2;
        return (lane * GAME_CONFIG.LANE_WIDTH) - centerOffset;
    }

    reset() {
        this.lane = 1;
        this.mesh.position.set(-4, 1, this.getZFromLane(this.lane));
        this.yVelocity = 0;
        this.isJumping = false;
        this.isFloating = false;
        this.invincibleTimer = 0;
        this.mesh.visible = true;
        this.onHole = false;
        this.falling = false;
        this.respawning = false;
        this.mesh.rotation.set(0,0,0);
        
        this.head.material.color.setHex(COLORS.PIYO_BODY);
        this.body.material.color.setHex(COLORS.PIYO_BODY);
    }

    moveLane(direction) {
        if (!gameState.isPlaying || this.falling || this.respawning) return;
        this.lane += direction;
        if (this.lane < 0) this.lane = 0;
        if (this.lane >= GAME_CONFIG.LANE_COUNT) this.lane = GAME_CONFIG.LANE_COUNT - 1;
    }

    jump(forceType = 'normal') {
        if (!gameState.isPlaying || this.falling || this.respawning) return;
        if (!this.isJumping || forceType === 'long') {
            this.isJumping = true;
            if (forceType === 'long') {
                this.yVelocity = GAME_CONFIG.LONG_JUMP_FORCE;
                this.isFloating = true; 
            } else {
                this.yVelocity = GAME_CONFIG.JUMP_FORCE;
                this.isFloating = false;
            }
        }
    }

    damage(amount) {
        if (this.invincibleTimer > 0 || this.falling || this.respawning) return; 

        gameState.hp -= amount;
        updateUI();
        flashScreen();
        this.setInvincible(60); 

        if (gameState.hp <= 0) {
            gameState.lives--;
            gameState.hp = 100;
            updateUI();
            if (gameState.lives <= 0) {
                gameOver();
            }
        }
    }

    heal(amount) {
        gameState.hp = Math.min(100, gameState.hp + amount);
        updateUI();
        // å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç·‘ã£ã½ãï¼‰
        this.head.material.emissive.setHex(0x004400);
        setTimeout(() => { this.head.material.emissive.setHex(0x000000); }, 200);
    }

    setInvincible(time = GAME_CONFIG.INVINCIBLE_TIME) {
        this.invincibleTimer = time;
    }

    handleFall() {
        if (!this.falling && !this.respawning) {
            this.falling = true;
            gameState.lives--;
            updateUI();
            flashScreen(); 

            if (gameState.lives > 0) {
                this.respawning = true;
                setTimeout(() => {
                    if(!gameState.isPlaying) return;
                    this.respawn();
                }, 1500);
            } else {
                setTimeout(() => {
                    this.die();
                }, 1000);
            }
        }
    }

    respawn() {
        this.falling = false; 
        this.mesh.position.y = 12; 
        this.mesh.position.z = this.getZFromLane(this.lane); 
        this.mesh.rotation.set(0,0,0); 
        this.yVelocity = 0; 
        this.isJumping = true; 
        this.onHole = false;   
        this.isFloating = false;
        gameState.hp = 100;
        // ãƒªã‚¹ãƒãƒ¼ãƒ³æ™‚ã¯å”è¾›å­åŠ¹æœã‚’ãƒªã‚»ãƒƒãƒˆ
        gameState.slowTimer = 0;
        updateUI();
        this.setInvincible(180);
        
        setTimeout(() => { this.respawning = false; }, 500);
    }

    die() {
        gameState.lives = 0;
        gameState.hp = 0;
        updateUI();
        gameOver();
    }

    update() {
        this.targetZ = this.getZFromLane(this.lane);
        // ã‚¹ãƒ­ãƒ¼æ™‚ã¯ãƒ¬ãƒ¼ãƒ³ç§»å‹•ã‚‚å°‘ã—ã‚†ã£ãã‚Šã«
        const lerpFactor = (gameState.slowTimer > 0) ? 0.1 : 0.2;
        this.mesh.position.z += (this.targetZ - this.mesh.position.z) * lerpFactor;

        if (this.isJumping) {
            // ã‚¹ãƒ­ãƒ¼æ™‚ã¯é‡åŠ›ã‚„ã‚¸ãƒ£ãƒ³ãƒ—é€Ÿåº¦ã‚‚å½±éŸ¿ã‚’å—ã‘ã‚‹ã¹ãã ãŒã€
            // æ“ä½œæ„Ÿã‚’æ‚ªãã—ã™ããªã„ãŸã‚ã«ã€ç‰©ç†æŒ™å‹•è‡ªä½“ã¯ã‚ã¾ã‚Šå¤‰ãˆãšã€
            // ã€Œä¸–ç•Œã®æµã‚Œã‚‹é€Ÿåº¦ã€ã ã‘ã‚’å¤‰ãˆã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã™ã‚‹ã€‚
            // ãŸã ã—ã€ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ„Ÿã‚’å‡ºã™ãŸã‚ã«å°‘ã—ã ã‘ã‚†ã£ãã‚Šå‹•ã‹ã™
            const timeScale = (gameState.slowTimer > 0) ? 0.7 : 1.0;

            this.mesh.position.y += this.yVelocity * timeScale;
            const currentGravity = this.isFloating ? GAME_CONFIG.FLOAT_GRAVITY : GAME_CONFIG.GRAVITY;
            this.yVelocity -= currentGravity * timeScale;

            if (this.isFloating) {
                this.mesh.rotation.z -= 0.15 * timeScale;
            } else {
                this.mesh.rotation.z += (0 - this.mesh.rotation.z) * 0.1;
            }

            if (this.mesh.position.y <= 1 && !this.onHole && !this.falling) {
                this.mesh.position.y = 1;
                this.isJumping = false;
                this.isFloating = false;
                this.yVelocity = 0;
                this.mesh.rotation.z = 0; 
            }
        } else {
            this.bounceOffset = (this.bounceOffset || 0) + ((gameState.slowTimer > 0) ? 0.1 : 0.2);
            if (!this.onHole) {
                this.mesh.position.y = 1 + Math.abs(Math.sin(this.bounceOffset)) * 0.2;
                this.mesh.rotation.z = Math.sin(this.bounceOffset) * 0.05; 
            } else {
                this.mesh.position.y -= 0.3;
                this.mesh.rotation.z += 0.2; 
                if (this.mesh.position.y < -5 && !this.falling) {
                    this.handleFall();
                }
            }
        }

        // ç„¡æ•µç‚¹æ»…
        if (this.invincibleTimer > 0) {
            this.invincibleTimer--;
            if (this.invincibleTimer % 10 < 5) {
                this.body.material.color.setHex(0xFFFF66); // Star color
            } else {
                this.body.material.color.setHex(COLORS.PIYO_BODY);
            }
            if (this.invincibleTimer === 0) {
                this.body.material.color.setHex(COLORS.PIYO_BODY);
            }
        }
    }
}

class World {
    constructor() {
        this.tiles = [];
        this.tileGroup = new THREE.Group();
        scene.add(this.tileGroup);
        this.sceneryGroup = new THREE.Group();
        scene.add(this.sceneryGroup);
        this.setupScenery();
        this.cols = 24; 
        for (let x = 0; x < this.cols; x++) {
            for (let z = 0; z < GAME_CONFIG.LANE_COUNT; z++) {
                this.createTile(x, z);
            }
        }
    }

    setupScenery() {
        for(let i=0; i<15; i++) {
            const size = 5 + Math.random() * 5;
            const geo = new THREE.PlaneGeometry(size, size);
            const mat = new THREE.MeshBasicMaterial({ 
                map: textureMap['cloud'], 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.set(
                Math.random() * 100 - 20, 
                2 + Math.random() * 10,   
                -10 - Math.random() * 10  
            );
            mesh.userData = { speedRate: 0.05 + Math.random() * 0.1 };
            this.sceneryGroup.add(mesh);
        }
    }

    createTile(gridX, laneIndex) {
        const size = GAME_CONFIG.TILE_SIZE;
        const geo = new THREE.BoxGeometry(size, 1, GAME_CONFIG.LANE_WIDTH - 0.1);
        const isEven = (gridX + laneIndex) % 2 === 0;
        const mat = isEven ? matGroundA : matGroundB;
        const mesh = new THREE.Mesh(geo, mat);
        mesh.receiveShadow = true;

        const z = (laneIndex * GAME_CONFIG.LANE_WIDTH) - ((GAME_CONFIG.LANE_COUNT - 1) * GAME_CONFIG.LANE_WIDTH / 2);
        const xStart = -10; 
        const x = xStart + gridX * size;
        mesh.position.set(x, -0.5, z);

        const tileData = {
            mesh: mesh,
            gridX: gridX,
            lane: laneIndex,
            type: 'normal',
            active: true
        };
        mesh.userData = tileData;
        this.tiles.push(tileData);
        this.tileGroup.add(mesh);
    }

    reset() {
        this.tiles.forEach(t => {
            const size = GAME_CONFIG.TILE_SIZE;
            const xStart = -10;
            t.mesh.position.x = xStart + t.gridX * size;
            this.resetTileType(t);
        });
    }

    resetTileType(tile) {
        tile.type = 'normal';
        tile.mesh.visible = true;
        tile.mesh.rotation.set(0, 0, 0);
        tile.mesh.position.y = -0.5;
        const isEven = (tile.gridX + tile.lane) % 2 === 0;
        tile.mesh.material = isEven ? matGroundA : matGroundB;
    }

    update() {
        // currentSpeedã‚’ä½¿ç”¨
        const speed = currentSpeed;
        const size = GAME_CONFIG.TILE_SIZE;
        const limitX = -30; 
        
        this.sceneryGroup.children.forEach(cloud => {
            cloud.position.x -= speed * cloud.userData.speedRate;
            if (cloud.position.x < -30) cloud.position.x = 80; 
        });

        this.tiles.forEach(tile => {
            tile.mesh.position.x -= speed;
            if (tile.mesh.position.x < limitX) {
                tile.mesh.position.x += (this.cols * size);
                this.resetTileType(tile);
                objectManager.spawnObjectOnTile(tile);
            }
        });
    }

    getTileAt(x, z) {
        return this.tiles.find(t => 
            Math.abs(t.mesh.position.x - x) < GAME_CONFIG.TILE_SIZE / 2 &&
            Math.abs(t.mesh.position.z - z) < 0.5
        );
    }
}

class ObjectManager {
    constructor() {
        this.objects = [];
        this.pool = [];
        this.objGroup = new THREE.Group();
        scene.add(this.objGroup);
    }

    reset() {
        this.objects.forEach(o => {
            o.mesh.visible = false;
            this.pool.push(o);
        });
        this.objects = [];
    }

    // Emojiãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ã£ãŸæ¿ãƒãƒªã‚´ãƒ³ã‚’ç”Ÿæˆã™ã‚‹å…±é€šé–¢æ•°
    createBoardMesh(textureName, scale = 1.0) {
        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(2 * scale, 2 * scale),
            new THREE.MeshBasicMaterial({ 
                map: textureMap[textureName], 
                transparent: true, 
                alphaTest: 0.5, 
                side: THREE.DoubleSide
            })
        );
        // å½±ã‚’è½ã¨ã™ãŸã‚ã«DepthMaterialã‚’è¨­å®š
        mesh.customDepthMaterial = new THREE.MeshDepthMaterial({
            depthPacking: THREE.RGBADepthPacking,
            map: textureMap[textureName],
            alphaTest: 0.5
        });
        mesh.castShadow = true;
        return mesh;
    }

    createMesh(type) {
        let mesh;
        if (type === 'cactus') {
            mesh = this.createBoardMesh('cactus');
        } else if (type === 'cake') {
            mesh = this.createBoardMesh('cake', 0.8);
        } else if (type === 'onigiri') {
            mesh = this.createBoardMesh('onigiri', 0.8);
        } else if (type === 'star') {
            mesh = this.createBoardMesh('star', 0.8);
        } else if (type === 'chili') {
            mesh = this.createBoardMesh('chili', 0.8);
        } else if (type === 'ghost') {
            mesh = this.createBoardMesh('ghost', 1.0);
        } else if (type === 'moving_block') {
            const geometry = new THREE.BoxGeometry(1.8, 1.8, 1.2);
            const matBase = new THREE.MeshLambertMaterial({ color: COLORS.BLOCK });
            const matDark = new THREE.MeshLambertMaterial({ color: 0x483D8B });
            mesh = new THREE.Mesh(geometry, [matBase, matBase, matDark, matDark, matBase, matBase]);
            mesh.castShadow = true;
        }
        
        if(mesh) {
            this.objGroup.add(mesh);
        }
        return mesh;
    }

    spawnObjectOnTile(tile) {
        const rand = Math.random();

        // 1. ç©´ (3%)
        if (rand < 0.03) {
            tile.type = 'hole';
            tile.mesh.visible = false; 
            return; 
        }
        
        // 2. ã‚¸ãƒ£ãƒ³ãƒ—å° (3%)
        if (rand < 0.06) {
            tile.type = 'spring';
            tile.mesh.material = matSpring;
            tile.mesh.rotation.z = 0.3; 
            tile.mesh.position.y = 0; 
            return;
        }

        // 3. ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
        // å‡¦ç†è½ã¡ã‚’é˜²ããŸã‚ã€å‡ºç¾ç‡ã‚’å°‘ã—æŠ‘ãˆã‚‹ (åˆè¨ˆ25%ç¨‹åº¦ã«)
        if (rand < 0.31) { 
            let type = null;
            const subRand = Math.random();
            
            // ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
            // æ•µ: ã‚µãƒœãƒ†ãƒ³(20%), ãƒ–ãƒ­ãƒƒã‚¯(10%), ã‚ªãƒã‚±(10%) -> åˆè¨ˆ40%
            // ã‚¢ã‚¤ãƒ†ãƒ : ã‚±ãƒ¼ã‚­(30%), ãŠã«ãã‚Š(15%), ã‚¹ã‚¿ãƒ¼(5%), å”è¾›å­(10%) -> åˆè¨ˆ60%

            if (subRand < 0.20) type = 'cactus';
            else if (subRand < 0.30) type = 'moving_block';
            else if (subRand < 0.40) type = 'ghost';
            else if (subRand < 0.70) type = 'cake';
            else if (subRand < 0.85) type = 'onigiri';
            else if (subRand < 0.90) type = 'star';
            else type = 'chili';

            // HPæº€ã‚¿ãƒ³ãªã‚‰ãŠã«ãã‚Šã‚’ã‚±ãƒ¼ã‚­ã«å¤‰ãˆã‚‹
            if (type === 'onigiri' && gameState.hp >= 100) {
                type = 'cake';
            }

            if (!type) return;

            let objData = this.pool.find(o => !o.active && o.type === type);
            if (!objData) {
                objData = { mesh: this.createMesh(type), type: type, active: false };
                this.objects.push(objData);
            } else {
                this.pool = this.pool.filter(o => o !== objData);
                this.objects.push(objData);
            }

            objData.active = true;
            objData.mesh.visible = true;
            objData.mesh.position.set(tile.mesh.position.x, 0.5, tile.mesh.position.z);
            objData.mesh.rotation.set(0,0,0);
            
            // é«˜ã•ãƒ»åˆæœŸå€¤èª¿æ•´
            if (type === 'cake' || type === 'onigiri' || type === 'star' || type === 'chili') {
                objData.mesh.position.y = 1.0;
            } else if (type === 'cactus') {
                objData.mesh.position.y = 0.8; 
            } else if (type === 'ghost') {
                objData.mesh.position.y = 1.5 + Math.random(); // ç©ºä¸­
                objData.phase = Math.random() * Math.PI * 2;
            } else if (type === 'moving_block') {
                objData.mesh.position.y = 1.2;
                objData.phase = Math.random() * Math.PI * 2;
            }
        }
    }

    update() {
        const speed = currentSpeed; // ã‚°ãƒ­ãƒ¼ãƒãƒ«é€Ÿåº¦ã‚’ä½¿ç”¨
        
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            obj.mesh.position.x -= speed;

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (['cake', 'onigiri', 'star', 'chili'].includes(obj.type)) {
                // ã‚¢ã‚¤ãƒ†ãƒ ã¯ãã‚‹ãã‚‹å›ã‚‹
                obj.mesh.rotation.y += 0.05;
                obj.mesh.position.y = 1.0 + Math.sin(gameState.frameCount * 0.1 + obj.mesh.id) * 0.2;
            } 
            else if (obj.type === 'moving_block') {
                // ãƒ–ãƒ­ãƒƒã‚¯ã¯ã‚†ã£ãã‚Šå·¦å³ç§»å‹•
                const zOffset = Math.sin(gameState.frameCount * 0.02 + obj.phase) * 6;
                obj.mesh.position.z = zOffset;
                obj.mesh.rotation.x += 0.03;
                obj.mesh.rotation.y += 0.03;
            }
            else if (obj.type === 'ghost') {
                // ã‚ªãƒã‚±ã¯ä¸è¦å‰‡ã«æµ®éŠ
                const t = gameState.frameCount * 0.03 + obj.phase;
                obj.mesh.position.y = 2.0 + Math.sin(t) * 0.8; 
                obj.mesh.position.z += Math.cos(t * 1.5) * 0.05; // å°‘ã—ãµã‚‰ãµã‚‰æ¨ªã«ã‚‚å‹•ã
                // å¸¸ã«ã‚«ãƒ¡ãƒ©ã®æ–¹ï¼ˆå°‘ã—æ–œã‚ï¼‰ã‚’å‘ãã‚ˆã†ã«ç°¡æ˜“ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰
                obj.mesh.lookAt(camera.position); 
            }

            if (obj.mesh.position.x < -30) this.deactivate(obj, i);
        }
    }

    deactivate(obj, index) {
        obj.active = false;
        obj.mesh.visible = false;
        this.objects.splice(index, 1);
        this.pool.push(obj);
    }

    checkCollision(player) {
        const pPos = player.mesh.position;
        
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            const oPos = obj.mesh.position;
            
            // 1. å‰å¾Œè·é›¢ (X)
            const dx = Math.abs(pPos.x - oPos.x);
            let hitX = 1.0;
            if (obj.type === 'moving_block') hitX = 1.6;

            if (dx > hitX) continue;

            // 2. å·¦å³è·é›¢ (Z)
            const dz = Math.abs(pPos.z - oPos.z);
            let hitZ = 1.2;
            if (obj.type === 'moving_block') hitZ = 1.8;
            if (obj.type === 'ghost') hitZ = 1.0;

            if (dz > hitZ) continue; 

            // 3. é«˜ã• (Y)
            const dy = Math.abs(pPos.y - oPos.y);
            let hitY = 1.2; 
            if (obj.type === 'cactus') hitY = 1.0; 
            if (['cake', 'onigiri', 'star', 'chili'].includes(obj.type)) hitY = 1.5;
            if (obj.type === 'moving_block') hitY = 1.8;
            if (obj.type === 'ghost') hitY = 1.0;

            if (dy > hitY) continue; 

            this.resolveCollision(player, obj, i);
        }
    }

    resolveCollision(player, obj, index) {
        const type = obj.type;

        // ã‚¢ã‚¤ãƒ†ãƒ ç³»
        if (type === 'cake') {
            gameState.score += 200; 
            updateUI();
            this.deactivate(obj, index);
        } else if (type === 'onigiri') {
            player.heal(30);
            this.deactivate(obj, index);
        } else if (type === 'star') {
            player.setInvincible(300); // 5ç§’
            this.deactivate(obj, index);
        } else if (type === 'chili') {
            // å”è¾›å­ï¼šã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ€ã‚¦ãƒ³
            gameState.slowTimer = 180; // 3ç§’é–“
            document.getElementById('slow-overlay').style.opacity = 1;
            this.deactivate(obj, index);
        } 
        // æ•µç³»
        else if (type === 'cactus' || type === 'moving_block' || type === 'ghost') {
            if (player.invincibleTimer > 0) return;
            
            // è¡çªæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
            if(type === 'moving_block') player.damage(35);
            else player.damage(25);
        }
    }
}

class InputManager {
    constructor() {
        this.startX = 0;
        this.startY = 0;
        this.isTouching = false;

        document.addEventListener('touchstart', this.onTouchStart.bind(this), {passive: false});
        document.addEventListener('touchmove', this.onTouchMove.bind(this), {passive: false});
        document.addEventListener('touchend', this.onTouchEnd.bind(this), {passive: false});
        document.addEventListener('mousedown', this.onMouseDown.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));
    }

    onTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isTouching = true;
    }

    onTouchMove(e) {
        if (!this.isTouching) return;
        if (gameState.isPlaying) e.preventDefault(); 
    }

    onTouchEnd(e) {
        if (!this.isTouching) return;
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        this.handleGesture(this.startX, this.startY, endX, endY);
        this.isTouching = false;
    }

    onMouseDown(e) {
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.isTouching = true;
    }
    onMouseUp(e) {
        if (!this.isTouching) return;
        this.handleGesture(this.startX, this.startY, e.clientX, e.clientY);
        this.isTouching = false;
    }

    handleGesture(x1, y1, x2, y2) {
        if (!gameState.isPlaying) return;

        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 30) {
            piyo.jump('normal');
        } else {
            if (Math.abs(dy) > Math.abs(dx)) {
                if (dy < 0) piyo.moveLane(-1); 
                else piyo.moveLane(1); 
            }
        }
    }
}

// --- 4. Game Loop & Logic ---

function startGame() {
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('result-area').classList.add('hidden');
    
    gameState.isPlaying = true;
    gameState.score = 0;
    gameState.lives = 3;
    gameState.hp = 100;
    gameState.frameCount = 0;
    gameState.slowTimer = 0;
    currentSpeed = GAME_CONFIG.BASE_SPEED;

    piyo.reset();
    world.reset();
    objectManager.reset();
    
    updateUI();
}

function gameOver() {
    gameState.isPlaying = false;
    document.getElementById('overlay').classList.remove('hidden');
    document.getElementById('title-text').innerText = "GAME OVER";
    document.getElementById('instructions').classList.add('hidden');
    
    const resultArea = document.getElementById('result-area');
    resultArea.classList.remove('hidden');
    document.getElementById('final-score').innerText = Math.floor(gameState.score);
    
    document.getElementById('start-btn').innerText = "ã‚‚ã†ä¸€åº¦";
    
    document.getElementById('slow-overlay').style.opacity = 0;
}

function updateUI() {
    let heartStr = "";
    for(let i=0; i<gameState.lives; i++) heartStr += "â¤ï¸";
    document.getElementById('lives').innerText = heartStr;
    document.getElementById('hp-bar').style.width = gameState.hp + "%";
    document.getElementById('score-board').innerText = Math.floor(gameState.score);
}

function flashScreen() {
    const flash = document.getElementById('damage-flash');
    flash.style.opacity = 0.5;
    setTimeout(() => { flash.style.opacity = 0; }, 100);
}

function checkTileGimmick() {
    if (piyo.isJumping && piyo.mesh.position.y > 2.0) return; 

    const tile = world.getTileAt(piyo.mesh.position.x, piyo.mesh.position.z);
    
    if (tile) {
        piyo.onHole = (tile.type === 'hole');
        if (tile.type === 'spring') piyo.jump('long');
    } else {
        piyo.onHole = false;
    }
}

function animate() {
    requestAnimationFrame(animate);

    if (gameState.isPlaying) {
        gameState.frameCount++;
        
        // å”è¾›å­ã«ã‚ˆã‚‹ã‚¹ãƒ­ãƒ¼åŠ¹æœã®ç®¡ç†
        if (gameState.slowTimer > 0) {
            gameState.slowTimer--;
            // ç›®æ¨™é€Ÿåº¦ã«å‘ã‹ã£ã¦å¾ã€…ã«å¤‰åŒ–ï¼ˆæ€¥æ¿€ãªå¤‰åŒ–ã‚’é˜²ãï¼‰
            currentSpeed += (GAME_CONFIG.SLOW_SPEED - currentSpeed) * 0.1;
            
            if (gameState.slowTimer === 0) {
                document.getElementById('slow-overlay').style.opacity = 0;
            }
        } else {
            // é€šå¸¸é€Ÿåº¦ã«æˆ»ã‚‹
            currentSpeed += (GAME_CONFIG.BASE_SPEED - currentSpeed) * 0.1;
        }

        world.update();
        objectManager.update();
        piyo.update();
        checkTileGimmick();
        objectManager.checkCollision(piyo);
    }

    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

init();

</script>
</body>
</html>
